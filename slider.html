<html>
<head>
<script>

/*

This is an experimental conversion of WebKit input[type=range] to the Web
Component API (see api-idl.txt). The point of this conversion is API discovery.

The original C++ code is here:

http://google.com/codesearch/p#OAMlx_jo-ck/src/third_party/WebKit/Source/WebCore/html/shadow/SliderThumbElement.cpp
http://google.com/codesearch/p#OAMlx_jo-ck/src/third_party/WebKit/Source/WebCore/html/RangeInputType.cpp

Additional API Surface:

[Supplemental]
interface DOMWindow {
    readonly attribute Fictional fictional;
}

// Things that don't exist in the real, but are necessary for conversion
// completeness.
interface Fictional {
    // Appearance hook, something to be fleshed out more.
    bool isSliderVertical(in Element element);

    // I was to lazy to write the actual code for this :)
    double proportionFromValue(in Element element);
    // Ditto.
    void setSliderValueFromProportion(in double proportion)
    // Ditto.
    void dispatchChangeEvent(in Element target);

    // There are no DOM equivalents for these.
    void setCapturingMouseEventsNode(in Element element);
    void clearCapturingMouseEventsNode();
}

*/

// FIXME: Doesn't handle -webkit-appearance or takes input from the RenderTheme.

function Slider() {}

Slider.prototype = {
    thumb: null,
    createShadowSubtree: function(scope)
    {
        this.thumb = document.createElement('x-slider-thumb');

        scope.shadow = this.thumb;
        scope.forwardPseudoElement('-webkit-slider-thumb', '>div');
        // FIXME: How can I get rid of this?
        scope.watchAttribute('value', this.thumb.setPositionFromValue.bind(this.thumb), true);

        this.addEventListener('mousedown', this.handleMouseDownEvent, false);
        this.addEventListener('keydown', this.handleKeyDownEvent, false);
    },
    handleMouseDownEvent: function(evt)
    {
        if (evt.button != 1 && evt.target() != this.element)
            return;

        this.thumb.dragFrom(new WebKitPoint(evt.clientX, evt.clientY));
    },
    handleKeyDownEvent: function(evt)
    {
        // FIXME: Implement.
    }
}

function SliderThumb() {}

SliderThumb.prototype = {
    createShadowSubtree: function(scope)
    {
        this.addEventListener('mousedown', this.handleMouseDownEvent, false);
        this.addEventListener('mouseup', this.handleMouseUpEvent, false);
        this.addEventListener('mousemove', this.handleMouseMoveEvent, false);
    },
    handleMouseDownEvent: function(evt)
    {
        if (evt.button != 1)
            return;

        this.startDragging();
    },
    handleMouseUpEvent: function(evt)
    {
        if (evt.button != 1)
            return;

        this.stopDragging();
    },
    handleMouseMoveEvent: function(evt)
    {
        if (!this.dragging)
            return;

        this.setPosition(new WebKitPoint(evt.clientX, evt.clientY));
    },
    moveTo: function(fraction)
    {
        var slider = this.parentElement;
        var vertical = fictional.isSliderVertical(slider);
        if (vertical)
            this.style.top = ((slider.offsetHeight - this.offsetHeight) * (1 - fraction)) + 'px';
        else
            this.style.left = ((slider.offsetWidth - this.offsetWidth) * fraction) + 'px';
    },
    setPositionFromValue: function(notification)
    {
        this.moveTo(fictional.proportionFromValue(notification.newValue));
    },
    setPosition: function(point)
    {
        var slider = this.parentElement;

        var localPoint = webkitConvertPointFromPageToNode(this, point);

        var trackSize;
        var position;
        var currentPosition;
        var vertical = fictional.isSliderVertical(slider);
        if (vertical) {
            trackSize = slider.offsetHeight;
            position = point.y - this.offsetHeight / 2;
            currentPosition = this.offsetTop - slider.offsetTop;
        } else {
            trackSize = slider.offsetWidth;
            position = point.x - this.offsetWidth / 2;
            currentPosition = this.offsetLeft - slider.offsetLeft;
        }
        position = Math.max(0, Math.min(position, trackSize));
        if (position == currentPosition)
            return;

        var fraction = position / trackSize;
        this.moveTo(fraction);
        fictional.setSliderValueFromProportion(slider, fraction);
        fictional.dispatchChangeEvent(slider);
    },
    dragFrom: function(point)
    {
        this.setPosition(point);
        this.startDragging();
    },
    startDragging: function()
    {
        fictional.setCapturingMouseEventsNode(this.element);
        this.dragging = true;
    },
    stopDragging: function()
    {
        if (!this.dragging)
            return;

        fictional.clearCapturingMouseEventsNode();
        this.dragging = false;
    }
}

function runTest()
{
    document.registerElement('div', 'slider', Slider);
    document.registerElement('div', 'slider-thumb', SliderThumb);
    var slider = document.createElement('x-slider');
    document.body.appendChild(slider);
}

</script>
</head>
<body onload="runTest()">
</body>
</html>