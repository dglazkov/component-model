<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html lang=en-US>
 <head>
  <title>Web Component Model</title>

  <style type="text/css">
   dt, dfn { font-weight: bold; font-style: normal; }
   .main h4 { margin: 1.5em 0 0.75em 0; }
   .main p { margin: 1em 0; }
   .main dl, .main dd { margin-top: 0; margin-bottom: 0; }
   .main dt { margin-top: 0.75em; margin-bottom: 0.25em; clear: left; }
   .main dd dt { margin-top: 0.25em; margin-bottom: 0; }
   .main dd p { margin-top: 0; }
   .main p + * > li, .main dd li { margin: 1em 0; }
   img.extra { float: right; }
   body ins, body del { display: block; }
   body * ins, body * del { display: inline; }
   pre, code { color: black; background: transparent; font-size: inherit; font-family: monospace; }
   pre strong { color: purple; background: transparent; font: inherit; font-weight: bold; }
   pre em { color: teal; background: transparent; font-weight: bolder; font-style: normal; }
   pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
   pre.idl { border: solid thin; background: #EEEEEE; color: black; padding: 0.5em; }
   table { border-collapse: collapse; border-style: hidden hidden none hidden; }
   table thead { border-bottom: solid; }
   table tbody th:first-child { border-left: solid; }
   table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
   table td > ul:first-child:last-child { margin: 0; padding: 0; }
   table td > ul:first-child:last-child li { margin: 0; padding: 0; list-style-position: inside; }
   ul.toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
   ul.toc li ul { margin-bottom: 0.75em; }
   ul.toc li ul li ul { margin-bottom: 0.25em; }
   var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
   @media screen { code { color: rgb(255, 69, 0); background: transparent; } }
   code :link, code :visited { color: inherit; background: transparent; }
   .example { display: block; color: #222222; background: #FCFCFC; border-left: double; margin: 1em 0 1em 1em; padding-left: 1em; }
   .issue, .big-issue { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
   .issue > :first-child, .big-issue > :first-child { margin-top: 0; }
   p .big-issue { line-height: 3em; }
   .note { color: green; background: transparent; }
   .note { font-family: sans-serif; }
   p.note:before { content: 'Note: '; }
   .warning { color: red; background: transparent; }
   .warning:before { font-style: normal; }
   p.warning:before { content: '\26A0 Warning! '; }
   .note, .warning { font-weight: bolder; font-style: italic; padding: 0.5em 2em; }
   .copyright { margin: 0.25em 0; }

   i.fixme:before { content: 'FIXME: '; font-weight: bold; }
   i.fixme { background-color: Red; color: White; padding: 0 0.5em; }
  </style>
  <link href="http://www.w3.org/StyleSheets/TR/W3C-CR" rel=stylesheet
  type="text/css">

 <body>
  <div class=head>
   <p><a href="http://www.w3.org/"><img alt=W3C height=48
    src="http://www.w3.org/Icons/w3c_home" width=72></a></p>

   <h1>Web Component Model</h1>
   <!--<h2 class="no-num no-toc">W3C Candidate Recommendation 16 March 2007</h2>-->
   
   <h2 class="no-num no-toc" id=w3c-working-draft-date>A work in progress
    2 March 2011</h2>

   <dl>
    <dt>This Version:

    <dd><a
     href="http://dglazkov.github.com/component-model/">http://dglazkov.github.com/component-model/</a>

    <dt>Latest Version:

    <dd><a href="http://www.w3.org/TR/xbl/">http://www.w3.org/TR/xbl/</a>

    <dt>Previous Versions:

    <dd><a
     href="http://www.w3.org/TR/2007/CR-xbl-20070316/">http://www.w3.org/TR/2007/CR-xbl-20070316/</a>

    <dd><a
     href="http://www.w3.org/TR/2007/WD-xbl-20070117/">http://www.w3.org/TR/2007/WD-xbl-20070117/</a>

    <dd><a
     href="http://www.w3.org/TR/2006/WD-xbl-20060907/">http://www.w3.org/TR/2006/WD-xbl-20060907/</a>

    <dd><a
     href="http://www.w3.org/TR/2006/WD-xbl-20060619/">http://www.w3.org/TR/2006/WD-xbl-20060619/</a>

    <dd><a
     href="http://www.mozilla.org/projects/xbl/xbl.html">http://www.mozilla.org/projects/xbl/xbl.html</a>

    <dd><a
     href="http://www.w3.org/TR/2001/NOTE-xbl-20010223/">http://www.w3.org/TR/2001/NOTE-xbl-20010223/</a>

    <dt>Editor:

    <dd><a href="mailto:ian@hixie.ch">Ian Hickson</a>, Google, Inc.
   </dl>
<!--
   <p class=copyright><a
    href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
    &#169; 2010 <a href="http://www.w3.org/"><acronym title="World Wide Web
    Consortium">W3C</acronym></a><sup>&#174;</sup> (<a
    href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute
    of Technology">MIT</acronym></a>, <a
    href="http://www.ercim.org/"><acronym title="European Research Consortium
    for Informatics and Mathematics">ERCIM</acronym></a>, <a
    href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a
    href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
    <a
    href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
    and <a
    href="http://www.w3.org/Consortium/Legal/copyright-documents">document
    use</a> rules apply.</p>

   <p class="alt copyright">The <a
    href="http://www.mozilla.org/projects/xbl/xbl2.html">Mozilla version</a>
    of this specification is available under a Creative Commons Attribution
    Share-alike license.</p>
  </div>
-->
  <hr>

  <div class=main>
<!-- FIXME: Rewrite
   <h2 class="no-num no-toc" id=abstract>Abstract</h2>

   <p>XBL (the Xenogamous Binding Language) describes the ability to
    associate elements in a document with script, event handlers, CSS, and
    more complex content models, which can be stored in another document.
    This can be used to re-order and wrap content so that, for instance,
    simple HTML or XHTML markup can have complex CSS styles applied without
    requiring that the markup be polluted with multiple semantically neutral
    <code title="">div</code> elements.</p>

   <p>It can also be used to implement new DOM interfaces, and, in
    conjunction with other specifications, enables arbitrary tag sets to be
    implemented as widgets. For example, XBL could be used to implement the
    form controls in XForms or HTML.</p>
-->
<!-- FIXME: Update
   <h2 class="no-num no-toc" id=status-of-this-document>Status of this
    document</h2>

   <p><em>This section describes the status of this document at the time of
    its publication. Other documents may supersede this document. A list of
    current W3C publications and the latest revision of this technical report
    can be found in the <a href="http://www.w3.org/TR/">W3C technical reports
    index</a> at http://www.w3.org/TR/.</em></p>
-->
   <!-- required boilerplate -->
   <!-- next few paragraphs give three required items: what this spec
  is, where to send comments, whether the spec is unstable, and the
  list of changes; wording is flexible -->
   <!-- LC:
  <p>This is the  3 September 2010 Last Call Working Draft of XBL 2.0. The last
  call for comments resulted in a number of process clarifications,
  and changes to various method and attribute names. This working
  draft is intended to allow commentors on the previous draft to
  verify their changes were correctly made before the specification
  advances to Candidate Recommendation. The deadline for Last Call
  comments is the 7 February 2007, after which time this draft
  will progress to Candidate Recommendation stage unless major issues
  have been found.</p>
  -->
   <!-- CR:
  <p>This is the 16 March 2007 Candidate Recommendation of XBL
  2.0. Implementations are encouraged. This specification will remain
  at the Candidate Recommendation stage until two complete and
  interoperable implementations exist (and not before 1 September
  2007). An implementation will only be considered if it is publicly
  downloadable or available through some other public point of sale
  mechanism, and is intended for a wide audience and could be used on
  a daily basis. To be "complete and interoperable", an implementation
  must pass every test in a comprehensive test suite of every
  normative requirement of this specification.</p>

  <p>Publication as a Candidate Recommendation does not imply
  endorsement by the W3C Membership. At the time of publication, there
  was no implementation report. A future version of this
  specification, which will include fixes based on implementation
  feedback, will include a link to a test suite and an implementation
  report.</p>
  -->
<!-- FIXME: Bring back when in relevant context
   <p>If you wish to make comments regarding this document, please send them
    to <a href="mailto:dev-tech-xbl@mozilla.org">dev-tech-xbl@mozilla.org</a>
    (<a href="https://lists.mozilla.org/listinfo/dev-tech-xbl">subscribe</a>,
    <a
    href="http://groups.google.com/group/mozilla.dev.tech.xbl">archives</a>)
    or <a href="mailto:public-webapps@w3.org">public-appformats@w3.org</a>
    (<a
    href="mailto:public-webapps-request@w3.org?subject=subscribe">subscribe</a>,
    <a
    href="http://lists.w3.org/Archives/Public/public-webapps/">archives</a>).
    All feedback is welcome. The editor guarantees that all feedback sent to
    the above lists will receive responses before this specification advances
    to the next stage of the W3C process.</p>
-->
<!-- FIXME: Bring back when in relevant context
   <p>The editor's copy of this specification is <a
    href="http://dev.w3.org/cvsweb/~checkout~/2006/xbl2/Overview.html?content-type=text/html">available
    in W3C CVS</a>. A <a href="http://dev.w3.org/cvsweb/2006/xbl2/">detailed
    list of changes</a> is available from the CVS server.</p>
-->
   <!-- next four paragraphs describe the history; optional -->
<!-- FIXME: Bring back when in relevant context
   <p>This specification is a (non-backwards-compatible) revision of
    Mozilla's XBL 1.0 language, originally developed at Netscape in 2000, and
    originally implemented in the Gecko rendering engine. <a
    href="#refsXBL10">[XBL10]</a></p>

   <p>This specification was developed by the Mozilla Foundation and its
    contributors, in conjunction with individuals from Opera Software ASA,
    Google, Inc, and Apple Computer, Inc, to address problems found in the
    original language and to allow for implementation in a broader range of
    Web browsers.</p>

   <p>This document is also based, in part, on work done in the W3C's
    Bindings Task Force. However, no text from that collaboration, other than
    that written by the aforementioned contributors, remains in this
    specification. Inspiration was similarly taken from other efforts, such
    as HTML Components. <a href="#refsHTC">[HTC]</a></p>

   <p>Although they have had related histories, this specification is
    separate from the W3C's "sXBL" drafts, and is not compatible with them.
    (The two efforts use different namespaces, for one.)</p>
-->
   <!-- next two paragraphs are legal things and w3c process -->
<!-- FIXME: Bring back when in relevant context
   <p>While the body of this specification was created outside the W3C, the
    W3C <a href="http://www.w3.org/2006/appformats/">Web Applications Working
    Group</a> is now guiding this specification along the W3C Recommendation
    track.</p>
-->
   <!-- this statement is
  required but the wording doesn't matter -->
<!-- FIXME: Bring back when in relevant context
   <p>This document was produced by a group operating under the <a
    href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February
    2004 W3C Patent Policy</a>. W3C maintains a <a
    href="http://www.w3.org/2004/01/pp-impl/38483/status"
    rel=disclosure>public list of any patent disclosures</a> made in
    connection with the deliverables of the group; that page also includes
    instructions for disclosing a patent. An individual who has actual
    knowledge of a patent which the individual believes contains <a
    href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
    Claim(s)</a> must disclose the information in accordance with <a
    href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
    6 of the W3C Patent Policy</a>.</p>
-->
   <!-- required boilerplate -->
   <h2 class="no-num no-toc" id=table-of-contents>Table of Contents</h2>
   <!--begin-toc-->
   <ul class=toc>
<!--
    <li><a href="#introduction"><span class=secno>1. </span>Introduction</a>
     <ul class=toc>
      <li><a href="#editors-note"><span class=secno>1.1. </span>Editor's
       note</a>

      <li><a href="#relationship-to-xbl1"><span class=secno>1.2.
       </span>Relationship to XBL1</a>

      <li><a href="#relationship-to-xslt"><span class=secno>1.3.
       </span>Relationship to XSLT</a>

      <li><a href="#terminology-and-conventions"><span class=secno>1.4.
       </span>Terminology and Conventions</a>

      <li><a href="#conformance"><span class=secno>1.5.
       </span>Conformance</a>
       <ul class=toc>
        <li><a href="#error-handling"><span class=secno>1.5.1. </span>Error
         Handling</a>

        <li><a href="#attributes-containing-selectors"><span
         class=secno>1.5.2. </span>Attributes Containing Selectors</a>

        <li><a href="#attributes-containing-space-separated-va"><span
         class=secno>1.5.3. </span>Attributes Containing Space-Separated
         Values</a>

        <li><a href="#attributes-containing-uris"><span class=secno>1.5.4.
         </span>Attributes Containing URIs</a>

        <li><a href="#attributes-containing-keywords"><span
         class=secno>1.5.5. </span>Attributes Containing Keywords</a>
       </ul>

      <li><a href="#security-concerns"><span class=secno>1.6. </span>Security
       Concerns</a>
     </ul>
-->
<!--
    <li><a href="#xbl-elements"><span class=secno>2. </span>XBL Elements</a>
     <ul class=toc>
      <li><a href="#the-binding-element"><span class=secno>2.1. </span>The
       <code>binding</code> Element</a>

      <li><a href="#the-implementation-element"><span class=secno>2.2.
       </span>The <code>implementation</code> Element</a>

      <li><a href="#the-template-element"><span class=secno>2.3. </span>The
       <code>template</code> Element</a>

      <li><a href="#the-content-element"><span class=secno>2.4. </span>The
       <code>content</code> Element</a>

      <li><a href="#the-inherited-element"><span class=secno>2.5. </span>The
       <code>inherited</code> Element</a>

      <li><a href="#the-attributes-attribute"><span class=secno>2.6.
       </span>The <code>attributes</code> Attribute</a>

      <li><a href="#the-pseudo-attribute"><span class=secno>2.7. </span>The
       <code>pseudo</code> Attribute</a>
     </ul>
-->
<!--
    <li><a href="#binding-attachment-and-detachment"><span class=secno>3.
     </span>Binding Attachment and Detachment</a>
     <ul class=toc>
      <li><a href="#the-bindings-are-ready-state"><span class=secno>3.1.
       </span>The Bindings-Are-Ready State</a>

      <li><a href="#attachment-using-ltbinding-elementgt"><span
       class=secno>3.2. </span>Attachment using <code
       title=binding>&lt;binding element=""&gt;</code></a>
       <ul class=toc>
        <li><a href="#importing-binding-documents"><span class=secno>3.2.1.
         </span>Importing Binding Documents</a>
       </ul>

      <li><a href="#attachment-using-css"><span class=secno>3.3.
       </span>Attachment using CSS</a>
       <ul class=toc>
        <li><a href="#the-binding-property"><span class=secno>3.3.1.
         </span>The '<code title="binding property">binding</code>'
         Property</a>

        <li><a href="#processing-model"><span class=secno>3.3.2.
         </span>Processing Model</a>

        <li><a href="#examples"><span class=secno>3.3.3. </span>Examples</a>
       </ul>

      <li><a href="#attachment-using-the-dom"><span class=secno>3.4.
       </span>Attachment using the DOM</a>

      <li><a href="#binding-attachment-model"><span class=secno>3.5.
       </span>Binding Attachment Model</a>

      <li><a href="#handling-insertion-and-removal-from-the-"><span
       class=secno>3.6. </span>Handling Insertion and Removal from the
       Document</a>

      <li><a href="#binding-inheritance"><span class=secno>3.7.
       </span>Binding Inheritance</a>
       <ul class=toc>
        <li><a href="#explicit-inheritance"><span class=secno>3.7.1.
         </span>Explicit Inheritance</a>

        <li><a href="#implicit-inheritance"><span class=secno>3.7.2.
         </span>Implicit Inheritance</a>

        <li><a href="#mixing-implicit-and-explicit-inheritance"><span
         class=secno>3.7.3. </span>Mixing Implicit and Explicit
         Inheritance</a>
       </ul>

      <li><a href="#attachment-during-document-load"><span class=secno>3.8.
       </span>Attachment During Document Load</a>

      <li><a href="#binding-detachment-model"><span class=secno>3.9.
       </span>Binding Detachment Model</a>
     </ul>
-->
    <li><a href="#shadow-content"><span class=secno>4. </span>Shadow
     Content</a>
     <ul class=toc>
      <li><a href="#rules-for-shadow-content-generation"><span
       class=secno>4.1. </span>Rules for Shadow Content Generation</a>

      <li><a href="#rules-for-shadow-content-destruction"><span
       class=secno>4.2. </span>Rules for Shadow Content Destruction</a>

      <li><a href="#attribute-forwarding"><span class=secno>4.3.
       </span>Attribute Forwarding</a>
       <ul class=toc>
        <li><a href="#forwarding-to-and-from-text-nodes"><span
         class=secno>4.3.1. </span>Forwarding to and from text nodes</a>

        <li><a href="#forwarding-language-metadata"><span class=secno>4.3.2.
         </span>Forwarding language metadata</a>

        <li><a href="#error-handling0"><span class=secno>4.3.3. </span>Error
         handling</a>

        <li><a href="#type-specifiers"><span class=secno>4.3.4. </span>Type
         specifiers</a>

        <li><a href="#dynamic-changes"><span class=secno>4.3.5.
         </span>Dynamic changes</a>

        <li><a href="#how-attribute-forwarding-affects-the-sha"><span
         class=secno>4.3.6. </span>How Attribute Forwarding Affects the
         Shadow Tree</a>
       </ul>

      <li><a href="#processing-content-elements"><span class=secno>4.4.
       </span>Processing <code>content</code> Elements</a>
       <ul class=toc>
        <li><a href="#how-nodes-are-distributed"><span class=secno>4.4.1.
         </span>How Nodes are Distributed</a>

        <li><a href="#when-nodes-are-redistributed"><span class=secno>4.4.2.
         </span>When Nodes Are Redistributed</a>
       </ul>

      <li><a href="#the-final-flattened-tree"><span class=secno>4.5.
       </span>The Final Flattened Tree</a>
       <ul class=toc>
        <li><a href="#terminology"><span class=secno>4.5.1.
         </span>Terminology</a>
       </ul>

      <li><a href="#handling-dom-changes"><span class=secno>4.6.
       </span>Handling DOM Changes</a>

      <li><a href="#shadow-content-and-css"><span class=secno>4.7.
       </span>Shadow Content and CSS</a>
       <ul class=toc>
        <li><a href="#selectors-and-shadow-scopes"><span class=secno>4.7.1.
         </span>Selectors and Shadow Scopes</a>

        <li><a href="#css-property-inheritance-and-rendering"><span
         class=secno>4.7.2. </span>CSS Property Inheritance and Rendering</a>
         

        <li><a href="#the-bound-element-pseudo-class"><span
         class=secno>4.7.3. </span>The <code>:bound-element</code>
         Pseudo-Class</a>

        <li><a href="#matching-pseudo-elements"><span class=secno>4.7.4.
         </span>Matching Pseudo-Elements</a>
       </ul>

      <li><a href="#shadow-content-and-xmlbase"><span class=secno>4.8.
       </span>Shadow Content and <code>xml:base</code></a>

      <li><a href="#shadow-content-and-other-things"><span class=secno>4.9.
       </span>Shadow Content and Other Things</a>
       <ul class=toc>
        <li><a href="#general-rules"><span class=secno>4.9.1. </span>General
         Rules</a>

        <li><a href="#style-blocks"><span class=secno>4.9.2. </span>Style
         Blocks</a>

        <li><a href="#script-blocks"><span class=secno>4.9.3. </span>Script
         Blocks</a>

        <li><a href="#html-forms"><span class=secno>4.9.4. </span>HTML
         Forms</a>

        <li><a href="#svg"><span class=secno>4.9.5. </span>SVG</a>
       </ul>

      <li><a href="#binding-style-sheets"><span class=secno>4.10.
       </span>Binding Style Sheets</a>
       <ul class=toc>
        <li><a href="#styleSummary"><span class=secno>4.10.1. </span>Summary
         of styling rules</a>
       </ul>
     </ul>
<!--
    <li><a href="#binding-implementations"><span class=secno>5.
     </span>Binding Implementations</a>
     <ul class=toc>
      <li><a href="#the-xblimplementation-interface"><span class=secno>5.1.
       </span>The <code>XBLImplementation</code> Interface</a>

      <li><a href="#the-xblimplementationlist-interface"><span
       class=secno>5.2. </span>The <code>XBLImplementationList</code>
       Interface</a>

      <li><a href="#accessing-binding-implementations"><span class=secno>5.3.
       </span>Accessing Binding Implementations</a>

      <li><a href="#creation-of-implementations"><span class=secno>5.4.
       </span>Creation of Implementations</a>
       <ul class=toc>
        <li><a href="#compiling-bindings"><span class=secno>5.4.1.
         </span>Compiling Bindings</a>

        <li><a href="#invoking-methods-on-an-implementation-ob"><span
         class=secno>5.4.2. </span>Invoking Methods on an Implementation
         Object</a>
       </ul>
     </ul>
-->
    <li><a href="#event-handlers"><span class=secno>6. </span>Event
     Handlers</a>
     <ul class=toc>
      <li><a href="#event-forwarding"><span class=secno>6.1. </span>Event
       Forwarding</a>

      <li><a href="#event-flow-and-targeting-across-shadow-s"><span
       class=secno>6.2. </span>Event Flow and Targeting Across Shadow
       Scopes</a>

      <li><a href="#the-default-phase"><span class=secno>6.3. </span>The
       Default Phase</a>

      <li><a href="#the-focus-domfocusin-blur-and-domfocusou"><span
       class=secno>6.4. </span>The <code>focus</code>,
       <code>DOMFocusIn</code>, <code>blur</code>, and
       <code>DOMFocusOut</code> Events</a>

      <li><a href="#the-mouseover-and-mouseout-events"><span class=secno>6.5.
       </span>The <code>mouseover</code> and <code>mouseout</code> Events</a>
       
     </ul>
<!--
    <li><a href="#dom-interfaces"><span class=secno>7. </span>DOM
     Interfaces</a>
     <ul class=toc>
      <li><a href="#the-documentxbl-interface"><span class=secno>7.1.
       </span>The <code>DocumentXBL</code> Interface</a>

      <li><a href="#the-elementxbl-interface"><span class=secno>7.2.
       </span>The <code>ElementXBL</code> Interface</a>
       <ul class=toc>
        <li><a href="#scoping-and-access-using-the-dom"><span
         class=secno>7.2.1. </span>Scoping and Access Using the DOM</a>
       </ul>

      <li><a href="#the-xblcontentelement-interface"><span class=secno>7.3.
       </span>The <code>XBLContentElement</code> Interface</a>

      <li><a href="#the-htmltemplateelement-interface"><span class=secno>7.4.
       </span>The <code>HTMLTemplateElement</code> Interface</a>

      <li><a href="#the-htmlbindingelement-interface"><span class=secno>7.5.
       </span>The <code>HTMLBindingElement</code> Interface</a>

      <li><a href="#the-eventxbl-interface"><span class=secno>7.6. </span>The
       <code>EventXBL</code> Interface</a>
     </ul>
    <li><a href="#resources"><span class=secno>8. </span>Resources</a>
     <ul class=toc>
      <li><a href="#loading-external-resources"><span class=secno>8.1.
       </span>Loading External Resources</a>
       <ul class=toc>
        <li><a href="#binding-documents"><span class=secno>8.1.1.
         </span>Binding Documents</a>

        <li><a href="#external-resources"><span class=secno>8.1.2.
         </span>External Resources</a>
       </ul>

      <li><a href="#loading-and-running-scripts"><span class=secno>8.2.
       </span>Loading and Running Scripts</a>
       <ul class=toc>
        <li><a href="#scripting"><span class=secno>8.2.1. </span>Scripting
         Model</a>
       </ul>

      <li><a href="#interpretation-of-uris-to-xbl-bindings"><span
       class=secno>8.3. </span>Interpretation of URIs to XBL bindings</a>
     </ul>

    <li><a href="#summaries"><span class=secno>9. </span>Summaries of
     Elements, Attributes, and Events</a>
     <ul class=toc>
      <li><a href="#elements-and-attributes"><span class=secno>9.1.
       </span>Elements and Attributes</a>

      <li><a href="#events"><span class=secno>9.2. </span>Events</a>

      <li><a href="#implementations"><span class=secno>9.3.
       </span>Implementations</a>
     </ul>

    <li class=no-num><a href="#acknowledgments">Acknowledgments</a>

    <li class=no-num><a href="#references">References</a>
-->
   </ul>
   <!--end-toc-->
   <hr>
<!-- FIXME: Needs update.
   <h2 id=introduction><span class=secno>1. </span>Introduction</h2>
   <blockquote>
    <p><dfn
     id=xemiddotnogmiddotamiddotmous>xe&middot;nog&middot;a&middot;mous</dfn>
     <i>adj.</i> Of or relating to the fertilization of elements from
     disparate trees.
   </blockquote>

   <p>This specification defines XBL (the Xenogamous Binding Language) and
    some supporting DOM interfaces and CSS features. XBL is a mechanism for
    overriding the standard presentation and interactive behavior of
    particular elements by attaching those elements to appropriate
    definitions, called <a href="#binding0" title=binding>bindings</a>.
    Bindings can be attached to elements using either CSS, the DOM, or by
    declaring, in XBL, that elements matching a specific selector are
    implemented by a particular binding. The element that the binding is
    attached to, called the <a href="#bound-element">bound element</a>,
    acquires the new behavior and presentation specified by the binding.</p>

   <p>Bindings can contain <span title=handlers>event handlers</span> that
    watch for events on the bound element, an <a
    href="#implementation">implementation</a> of new methods and properties
    that become accessible from the bound element, <a
    href="#shadow-content0">shadow content</a> that is inserted underneath
    the bound element, and associated <span>resources</span> such as scoped
    style sheets and precached images, sounds, or videos.</p>

   <p><span title="Except if script invoked by XBL explicitly changes the
    original DOM.">XBL cannot be used to give a document new
    semantics.</span> The meaning of a document is not changed by any
    bindings that are associated with it, only its presentation and
    interactive behavior.</p>

   <div class=example id=intro-example>
    <p>To help readers understand how certain features can be used, this
     specification includes some examples.</p>

    <p>In these examples, a long ellipsis ("...") is used to indicate elided
     content that would be present in a full example but has been removed for
     clarity.</p>

    <p>Here we see a simple binding being used to reorder content in an HTML
     page, so that the element with <code>class="nav"</code> is positioned
     before the element with <code>class="main"</code>. CSS associated with
     the binding is then used to position the two elements.</p>

    <pre>&lt;binding id="nav-then-main">
 &lt;template>
  &lt;style scoped>
   #wrapper { display: table-row; }
   #col1, #col2 { display: table-cell; }
  &lt;/style>
  &lt;div id="wrapper">
   &lt;div id="col2">&lt;content includes=".nav">&lt;/div>
   &lt;div id="col1">&lt;content includes=".main">&lt;/div>
  &lt;/div>
 &lt;/template>
&lt;/binding></pre>

    <p>The HTML page associated with such a binding might look like:</p>

    <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Demo&lt;/title>
  &lt;link rel="stylesheet" href="example.css">
 &lt;/head>
 &lt;body>
  &lt;div class="main">
   &lt;h1>Demo&lt;/h1>
   ...
  &lt;/div>
  &lt;div class="nav">
   &lt;p>&lt;a href="http://example.com/">Home&lt;/a>&lt;/p>
   ...
  &lt;/div>
 &lt;/body>
&lt;/html></pre>

    <p>The CSS stylesheet referred to from that document would include
     various stylistic rules, and would in particular contain a link to the
     XBL file, making it apply to the <code>body</code> element so as to
     reorder the two child elements:</p>

    <pre>/* Colors and Fonts */
h1 { font: 2em sans-serif; color: green; background: white; }
...

/* Reorder content */
body { binding: url(example.xbl#nav-then-main); }</pre>

    <p>The result of all the above is equivalent to the result one would get
     if one simply placed the <code title="">div</code> element with
     <code>class="nav"</code> before the <code title="">div</code> element
     with <code>class="main"</code>. However, the effect is achieved without
     needing any changes to the markup. This allows the same markup to be
     given different presentations dynamically. It also allows changes to be
     applied across entire sites by merely changing global stylesheet and
     binding files, much as CSS can be used to change the layout and
     presentation of a site even without XBL.</p>
   </div>

   <div class=example id=simple-shadow-example>
    <p>Here is another example, this time of an inaccessible implementation
     of the proposed HTML5 <code title="">details</code> disclosure element:
     it opens and closes when clicked, and reflects its current state in the
     element's "<code>open</code>" attribute.</p>

    <pre>&lt;binding element="details">
 &lt;template>
  &lt;style scoped>
   #container[data-state=hidden] { display: none; }
  &lt;/style>
  &lt;div>
   &lt;div>&lt;content includes="summary:first-child">Details...&lt;/content>&lt;/div>
   &lt;div data-state="hidden" id="container">&lt;content>&lt;/content>&lt;/div>
  &lt;/div>
 &lt;/template>
 &lt;implementation>
  ({
    get open() { return this.boundElement.hasAttribute('open'); },
    set open(val) {
      if (val)
        this.boundElement.setAttribute('open', 'open');
      else
        this.boundElement.removeAttribute('open');
      return this.open;
    },
    xblBindingAttached: function () {
      this.addEventListener('click', function () { this.open = !this.open }, false);
      this.addEventListener('DOMAttrModified', function (event) {
        if (event.attrName = 'open') {
          if (event.attrChange = MutationEvent.ADDITION) {
            this.shadowTree.getElementById('container').dataset.state = 'visible';
          } else if (event.attrChange = MutationEvent.REMOVAL) {
            this.shadowTree.getElementById('container').dataset.state = 'hidden';
          }
        }
      }, false);
    },
  })
 &lt;/implementation>
&lt;/binding></pre>
   </div>

   <p class=note>Since the examples are all untested (there are no XBL2
    implementations at the time of writing), it is quite possible that they
    have errors. Please report any errors you think you see, so that we can
    correct the examples.</p>
   <h3 id=editors-note><span class=secno>1.1. </span>Editor's note</h3>

   <p>This specification was updated (as of Septemebr 2010) to make the
    following broad changes:</p>

   <ul>
    <li>Moving XBL to just be part of HTML, rather than having its own
     namespace and requiring XML.

    <li>Removing a number of features so as to reduce the initial
     implementation burden: <code>handlers</code> (events forward to the <a
     href="#internal-object">internal object</a> now, and that object
     implements <code>EventTarget</code>); <code>style</code> and
     <code>script</code> are replaced by HTML equivalents;
     <code>prefetch</code> and <code>handler</code> are removed altogether;
     removed support for namespaces.

    <li>Making <a
     href="#loadbindingdocument"><code>loadBindingDocument()</code></a>
     asynchronous.

    <li>Adding an API to allow XBL to be manipulated from script.
   </ul>

   <p>This specification is not written in the strictest style; in many
    places it is rather hand-wavy and fails to define things strictly (e.g.
    in terms of event loops, WebIDL, and other such mechanisms that allow us
    to define the Web platform strictly). If this update to XBL2 is more
    successful than the previous draft, then it will likely be merged into
    the HTML specification, and the processing models will be rewritten to be
    much more well-defined. In particular, this will include making <a
    href="#binding0"><code>binding</code></a> get parsed in <code>head</code>
    elements, and the syntax being updated to define that you can't use <a
    href="#content"><code>content</code></a> or <a
    href="#inherited"><code>inherited</code></a> in places that are handled
    in an insertion mode other than "in body".</p>
   <h3 id=relationship-to-xbl1><span class=secno>1.2. </span>Relationship to
    XBL1</h3>

   <p>This specification is not backwards compatible with XBL1.</p>

   <p>There are numerous changes. However, of particular importance to
    readers familiar with XBL1, there have been some changes to the element
    names. In particular, the XBL1 element <code title="">content</code> is
    now called <a href="#template"><code>template</code></a>, and the XBL1
    element <code title="">children</code> is now called <a
    href="#content"><code>content</code></a>.</p>

   <h3 id=relationship-to-xslt><span class=secno>1.3. </span>Relationship to
    XSLT</h3>

   <p>This specification has a similar scope to XSLT. The main differences
    are:</p>

   <ul>
    <li>
     <p>XSLT operates on a static DOM, permanently replacing that DOM for
      rendering. XBL, on the other hand, transparently transforms the DOM for
      rendering while leaving the underlying structure intact, and
      dynamically reflects changes to the underlying DOM in the transformed
      rendering.

    <li>
     <p>XSLT allows any arbitrary transformation to be performed. XBL shadow
      trees, on the other hand, only support reordering of the bound
      element's child nodes and interleaving of those explicit children with
      shadow content. Arbitrary transformations are not possible in XBL while
      retaining the transparent nature of XBL's shadow tree processing.
   </ul>

   <p>In addition, XBL can be used for component creation, which is not
    covered by XSLT.</p>

   <h3 id=terminology-and-conventions><span class=secno>1.4.
    </span>Terminology and Conventions</h3>

   <p>An <dfn id=xbl-user-agent title="XBL user agents">XBL user agent</dfn>
    is an implementation that attempts to support this specification.</p>

   <p>A <dfn id=binding title="">binding</dfn> is the definition of behavior
    that can be applied to an element so as to augment its presentation.</p>

   <p>The namespace of all the <dfn id=xbl-elements0>XBL elements</dfn> must
    be the same as HTML: <code class=uri>http://www.w3.org/1999/xhtml</code>

   <p>The term <dfn id=binding-document>binding document</dfn> is used to
    mean a <code>Document</code> containing one or more <a
    href="#binding0"><code>binding</code></a> elements.</p>

   <div class=example id=date-example>
    <p>Here is a <a href="#binding-document">binding document</a>. The
     binding is highlighted.</p>

    <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Demo&lt;/title>
  &lt;script>
    function fmt(n) {
      if (n < 10)
        return "0" + n;
      else
        return n;
    }
  &lt;/script>
  <strong>&lt;binding element=".date">
   &lt;implementation>
     ({
       xblBindingAttached: function() {
         var tm = /(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d) UTC$/.exec(this.boundElement.textContent);
         var date = new Date();
         date.setUTCFullYear(parseInt(tm[1], 10));
         date.setUTCMonth(parseInt(tm[2], 10) - 1);
         date.setUTCDate(parseInt(tm[3], 10));
         date.setUTCHours(parseInt(tm[4], 10));
         date.setUTCMinutes(parseInt(tm[5], 10));
         date.setUTCSeconds(0);
         this.boundElement.textContent = date.getFullYear() + "-" +
                                     fmt(date.getMonth() + 1) + "-" +
                                     fmt(date.getDate()) + " " +
                                     fmt(date.getHours()) + ":" +
                                     fmt(date.getMinutes()) + " LT";
         this.boundElement.title = "Adjusted to local time zone"
       },
     })
   &lt;/implementation>
  &lt;/binding></strong>
 &lt;/head>
 &lt;body>
  &lt;h1>Demo&lt;/h1>
  &lt;p class="date">2006-08-10 18:40 UTC&lt;/p>
  &lt;p>...&lt;/p>
 &lt;/body>
&lt;/html></pre>

    <p>(As an aside, the binding defined in this example causes elements with
     <code>class="date"</code> to have their content parsed into a UTC date
     and converted into a local time. The binding mutates the original DOM to
     do this, and it doesn't reflect any dynamic changes made to the
     element's content; there are better, albeit slightly more involved, ways
     of achieving the same effect that don't have these problems.)</p>
   </div>

   <p>A <dfn id=bound-element>bound element</dfn> is an XML or HTML element
    to which a binding has been applied.</p>

   <p class=example>In the <a href="#date-example">example above</a>, the
    first <code>p</code> element is the <a href="#bound-element"><em>bound
    element</em></a>.</p>

   <p>A <dfn id=bound-document>bound document</dfn> is an XML or HTML
    document containing one or more <a href="#bound-element" title="bound
    element">bound elements</a>.</p>

   <p class=example>In the <a href="#date-example">example at the top of this
    section</a>, the document is both the <a
    href="#binding-document"><em>binding document</em></a> (because it
    contains the definition of the binding), and the <a
    href="#bound-document"><em>bound document</em></a> (because it contains
    the affected <a href="#bound-element"><em>bound element</em></a>). In the
    <a href="#intro-example">example in the introduction section</a>, the
    HTML file is the <a href="#bound-document"><em>bound document</em></a>,
    and the XBL file is the <a href="#binding-document"><em>binding
    document</em></a>.</p>

   <p>In this specification, the term <dfn id=in-error>in error</dfn>,
    typically used of an element or attribute, means that the element,
    attribute, or other construct is not conformant according to the rules of
    this specification. Rules for exactly how the construct must be treated
    when it is in error are always given when the term is used. Typically
    this will involve <dfn id=ignoring title=ignore>ignoring</dfn> the
    erroneous nodes, meaning the UA must, <em>for the purposes of XBL
    processing</em>, act as if those nodes were absent. UAs must not,
    however, remove such nodes from the DOM in order to ignore them, nor
    should it change what DOM interfaces those nodes implement. The nodes
    retain all their non-XBL semantics.</p>

   <p>UAs should report all errors to users, although they may do this in an
    unobtrusive way, for example in an error console.</p>

   <p>In addition to the error handling rules given in this specification,
    UAs may abort all processing when encountering an error.</p>

   <p class=note>Aborting is only likely to be a viable error handling
    mechanism in controlled environments, e.g. in conformance checkers. Web
    browsers are expected to use the error recovery mechanisms described in
    this specification, not abort.</p>

   <p>A <dfn id=correct title=correct>correct</dfn> element, attribute,
    value, or binding is one which is not <a href="#in-error">in error</a>.</p>

   <div class=example id=correct-vs-error-example>
    <p>The following fragment has a <a
     href="#content"><code>content</code></a> element that is <a
     href="#in-error">in error</a> because its <a href="#includes"><code
     title=attr-content-includes>includes</code></a> attribute has an invalid
     selector:</p>

    <pre>&lt;binding id="demo">
 &lt;template>
  &lt;content includes="<strong>@</strong>">&lt;/content>
 &lt;/template>
&lt;/binding></pre>
   </div>

   <p>The term "<dfn id=semantics>semantics</dfn>" is used to refer to the
    <em>intrinsic meaning</em> or processing model of elements, attributes,
    events, and DOM interface members. Semantics are defined by
    specifications; for example, this specification defines the semantics of
    XBL elements.</p>

   <p>When this specification refers to <em>elements in a namespace</em>, it
    does not exclude elements in <em>no</em> namespace; the null namespace is
    considered a namespace like any other for the purposes of XBL processing.</p>

   <p>All element names, attribute names, and attribute values in XBL are
    case sensitive, with the exception of attribute values defined by other
    specifications (those have the sensitivity defined by those other
    specifications).</p>

   <p class=note>The HTML parser lowercases all elements and attribute names,
    so it can appear like XBL is case-insensitive when used in HTML. However,
    that's actually a feature of the HTML parser, not of XBL.</p>

   <p>An <dfn id=xml-mime-type>XML MIME type</dfn> is <code>text/xml</code>,
    <code>application/xml</code>, or any MIME type ending with the string
    <code>+xml</code> (ignoring any MIME parameters).</p>

   <p>The terms "<dfn id=author-style-sheets>author style sheets</dfn>",
    "<dfn id=user-style-sheets>user style sheets</dfn>", "<dfn
    id=user-agent-style-sheets>user agent style sheets</dfn>", and "<dfn
    id=pseudo-element>pseudo-element</dfn>" are used as defined by the CSS
    specifications. <a href="#refsCSS21">[CSS21]</a></p>
   <h3 id=conformance><span class=secno>1.5. </span>Conformance</h3>
   <p>As well as sections marked as non-normative, all diagrams, examples,
    and notes in this specification are non-normative. Everything else in
    this specification is normative.</p>

   <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the
    normative parts of this document are to be interpreted as described in
    RFC2119. For readability, these words do not appear in all uppercase
    letters in this specification. <a href="#refsRFC2119">[RFC2119]</a></p>

   <p>There are two classes of products that can claim conformance to this
    implementation: <span>binding documents</span>, and <a
    href="#xbl-user-agent">XBL user agents</a>.</p>

   <p><span>Binding documents</span> must satisfy the constraints described
    in this specification in order to be considered conformant.</p>

   <p>Products that generate binding documents cannot claim conformance to
    this specification, though they can claim to only produce binding
    documents that themselves are conformant to this specification.</p>

   <p><a href="#xbl-user-agent">XBL user agents</a> must behave as described
    by this specification in order to be considered conformant, even when
    faced with non-conformant content.</p>

   <p>User agents may optimize any algorithm given in this specification, so
    long as the end result is indistinguishable from the result that would be
    obtained by the specification's algorithms. (The algorithms in this
    specification are generally written with more concern for clarity than
    over efficiency.)</p>

   <p id=dom-basis>This specification is defined in terms of the DOM. The
    language in this specification assumes that the user agent expands all
    entity references, and therefore does not include entity reference nodes
    in the DOM. If user agents do include entity reference nodes in the DOM,
    then user agents must handle them as if they were replaced by their DOM
    replacement values when implementing this specification.</p>

   <p class=example>For example, if a requirement talks about an element's
    child text nodes, then any text nodes that are children of an entity
    reference that is a child of that element would be used as well.</p>

   <h4 id=error-handling><span class=secno>1.5.1. </span>Error Handling</h4>

   <p>This specification describes the rules for processing of XBL elements
    and related features, whether they are used in a conformant manner or
    not. Conformant implementations, therefore, will interoperably handle any
    content, whether valid or not.</p>

   <h4 id=attributes-containing-selectors><span class=secno>1.5.2.
    </span><dfn id=attributes-containing-selectors0 title=selector>Attributes
    Containing Selectors</dfn></h4>

   <p>The <a href="#element"><code
    title=attr-binding-element>element</code></a> attribute of the <a
    href="#binding0"><code>binding</code></a> element and the <a
    href="#includes"><code title=attr-content-includes>includes</code></a>
    attribute of the <a href="#content"><code>content</code></a> element, if
    specified, must have their values parsed according to the rules in the
    Selectors specification. <a href="#refsSELECTORS">[SELECTORS]</a></p>

   <p class=note>This specification does not specify what level of Selectors
    support is required.</p>

   <p>Namespace prefixes cannot be used with selectors in XBL, as there is no
    way to declare the prefixes. The default namespace in selectors in XBL
    attributes is always unbound.</p>

   <div class=example id=selectors-example>
    <p>The following fragment defines a binding that is bound to elements
     declaring links (e.g. the <code title="">a</code> element in HTML).</p>

    <pre>&lt;binding element=":link, :visited">
 ...
&lt;/binding></pre>

    <p>This example defines a binding that matches elements with the name
     <code>a</code>, regardless of what namespace they are in. This would
     match both the HTML <code>a</code> element and the SVG <code>a</code>
     element.</p>

    <pre>&lt;binding element="a">
 ...
&lt;/binding></pre>
   </div>

   <h4 id=attributes-containing-space-separated-va><span class=secno>1.5.3.
    </span><dfn id=attributes-containing-space-separated-va0
    title=space-separated>Attributes Containing Space-Separated Values</dfn></h4>

   <p>Some attributes are defined as taking space-separated values. The list
    of values for such attributes must be obtained by taking the attribute's
    value, replacing any sequences of U+0009, U+000A, U+000D, and U+0020
    characters (in any order) with a single U+0020 SPACE character, dropping
    any leading or trailing U+0020 SPACE character, and then chopping the
    resulting string at each occurrence of a U+0020 character, dropping that
    character in the process.</p>

   <p>A space-separated attribute whose value is the empty string, or which
    consists of only U+0009, U+000A, U+000D, and U+0020 characters, has no
    values.</p>

   <div class=example id=space-separated-example>
    <p>In the attribute <code>attributes="1 2"</code>, the values are "1" and
     "2".</p>

    <p>In the attribute
     <code>class="&nbsp;&nbsp;key&nbsp;-&nbsp;note&nbsp;-&nbsp;rocks"</code>,
     there are five keywords: "key", "note", "rocks", and two occurrences of
     the single-character keyword "-".</p>
   </div>

   <h4 id=attributes-containing-uris><span class=secno>1.5.4. </span><dfn
    id=attributes-containing-uris0 title=URI>Attributes Containing URIs</dfn></h4>

   <p>Some attributes, pseudo-attributes, and method arguments are defined as
    specifying URIs. Such attributes must have values that match the <code
    title="">URI</code> token of RFC 3986 or the <code title="">IRI</code>
    token of RFC 3987. If they do not, they are <a href="#in-error">in
    error</a> (though the processing of erroneous URIs varies depending on
    the context). <a href="#refsRFC3986">[RFC3986]</a> <a
    href="#refsRFC3987">[RFC3987]</a></p>

   <h4 id=attributes-containing-keywords><span class=secno>1.5.5.
    </span>Attributes Containing Keywords</h4>

   <p>Certain attributes are defined as requiring certain values, e.g. <code
    title="">true</code> or <code title="">false</code>. For such attributes,
    the values must be specified exactly, in the case given in this
    specification, and with no leading or trailing whitespace.
    Implementations must only perform literal comparisons, and must not use
    case-insensitive comparisons nor trim attribute values before comparison.</p>

   <h3 id=security-concerns><span class=secno>1.6. </span>Security Concerns</h3>

   <p><em>This section is non-normative.</em></p>

   <p>XBL raises a number of security concerns.</p>

   <p><strong>Data theft</strong>: A na&iuml;ve implementation of XBL would
    allow any document to bind to bindings defined in any other document, and
    (since referencing a binding allows full access to that binding
    document's DOM) thereby allow access to any remote file, including those
    on intranet sites or on authenticated extranet sites. XBL prevents this
    by diallowing cross-origin bindings.</p>
-->
   <!-- mention CORS -->
<!-- continuing the FIXME...
   <p><strong>Privilege escalation</strong>: In conjunction with data theft,
    there is the concern that a page could bind to a binding document on a
    remote site, and then use the privileges of that site to obtain further
    information. XBL prevents this by requiring that the bindings all run in
    the security context of the <a href="#bound-document"><em>bound
    document</em></a>, so that accessing a remote binding document does not
    provide the bound document with any extra privileges on the remote
    domain.</p>

   <p><strong>Cookie theft</strong>: Related to privilege escalation is the
    risk that once an access-controlled binding document hosted on a remote
    site has been loaded, authentication information stored in cookies for
    that domain would become accessible to the bound document. XBL prevents
    this by requiring that the <code>cookie</code> attribute on the
    <code>HTMLDocument</code> interface be set to null.</p>

   <p><strong>Secure bindings</strong>: Using XBL for bindings that need
    access to the local filesystem, e.g. for implementing File Upload form
    controls, is not yet handled by this specification. However, a future
    version will provide a secure way to define an XBL binding that can be
    used to implement privileged mechanisms that can then be used by other
    bindings to provide such controls.</p>
-->
<!-- FIXME: Needs update.
   <h2 id=xbl-elements><span class=secno>2. </span>XBL Elements</h2>

   <p>When an XBL element is found inside an element other than those listed
    under the "Expected contexts" list in the definitions below, it is <a
    href="#in-error">in error</a>. When an XBL element has a child node that
    does not satisfy the "Expected children" list in its definition (for
    instance because it is the wrong node type, wrong element type, or
    because too many elements of its type preceded it), the <em>child</em> is
    <a href="#in-error">in error</a>. In both cases, being <a
    href="#in-error">in error</a> means that the UA must, for the purposes of
    XBL evaluation, treat the element and its descendants as it would if the
    erroneous node and all its descendants were not present in the DOM.</p>

   <p>However, non-XBL elements retain their semantics, even when considered
    to be <a href="#in-error">in error</a> for the purposes of XBL.</p>

   <p>Regardless of the requirements of the last few paragraphs and of the
    "expected children" lines, comment nodes, and text and CDATA nodes
    containing only whitespace characters, may always be given as children of
    XBL elements.</p>

   <p>For cases where attributes on XBL elements do not conform to this
    specification, the error handling is similar: the attributes must be
    considered to be <a href="#in-error">in error</a> and the UA must <a
    href="#ignoring">ignore</a> them, meaning that the presence of these
    non-conforming attributes in no way affects the XBL processing.</p>

   <p>Further error handling rules for more specific cases are given where
    appropriate.</p>

   <p>XBL user agents that support CSS should act as if they had the
    following rules in their UA style sheet:</p>

   <pre>@namespace html url(http://www.w3.org/1999/xhtml);
html|binding, html|implementation, html|template, html|content, html|inherited { display: none; }</pre>

   <p>XBL user agents that do not support CSS should not render XBL elements.</p>

   <p class=note>The following sections describe the <em>content model</em>
    of XBL elements, but not their actual processing model. The processing
    model for XBL is described in later sections.</p>

   <h3 id=the-binding-element><span class=secno>2.1. </span>The <dfn
    id=binding0><code>binding</code></dfn> Element</h3>

   <dl>
    <dt>Expected context:

    <dd><span>Metadata content</span> (e.g. an HTML <code>head</code>
     element)

    <dt>Expected children (in any order):

    <dd><a href="#implementation"><code>implementation</code></a>: zero or
     one.

    <dd><a href="#template"><code>template</code></a>: zero or one.
   </dl>

   <div class=note>
    <p>The <a href="#binding0"><code>binding</code></a> element describes a
     single XBL binding that adds presentation and interactive behavior to
     XML or HTML elements. Each binding has these optional components:</p>

    <p><a href="#implementation"><em title=implementation>Methods,
     Properties, and Fields</em></a>: A binding can specify additional
     methods that can be invoked on the element. It can also specify
     additional properties and fields that can be retrieved or set on the
     element. In this way the functionality of the bound element becomes
     extensible. (See: <a href="#binding-implementations0">binding
     implementations</a>.)</p>

    <p><a href="#template"><em>Template</em></a>: The optional <a
     href="#template"><code>template</code></a> defines the initial <a
     href="#shadow-content0"><em>shadow content</em></a> for the bound
     element.</p>

    <p>Bindings can act as an attachment mechanism, specifying elements to
     associate with the given binding when the binding is <span
     title=importing>imported</span>, using the <a href="#element"><code
     title=attr-binding-element>element</code></a> attribute.</p>
   </div>

   <h4 class="no-toc no-num" id=attributes>Attributes</h4>

   <dl>
    <dt>Global attributes

    <dd>Any of HTML's global attributes.

    <dt><dfn id=extends title=attr-binding-extends>extends</dfn>

    <dd>The <a href="#extends"><code
     title=attr-binding-extends>extends</code></a> attribute is used to
     specify the <a href="#attributes-containing-uris0">URI</a> of a binding
     that this binding inherits from. (See: <a
     href="#interpretation-of-uris-to-xbl-bindings0">interpretation of URIs
     to XBL bindings</a>.) If the URI is <a href="#in-error">in error</a> or
     does not refer to another binding, the UA must <a
     href="#ignoring">ignore</a> it, meaning that this binding does not
     explicitly inherit from another binding. (See: <a
     href="#explicit-inheritance0">explicit inheritance</a>.) Only one URI
     can be specified.

    <dt><dfn id=element title=attr-binding-element>element</dfn>

    <dd>
     <p>This attribute, if specified, must contain a <a
      href="#attributes-containing-selectors0">selector</a>. All elements in
      the binding document, and in any documents that <span
      title=importing>import</span> the binding document, that <a
      href="#selectors-and-shadow-scopes0" title="selectors and shadow
      scopes">match the given selector</a>, must be bound to the binding
      defined by this <a href="#binding0"><code>binding</code></a> element.
      (The element's own shadow tree, if any, must not be taken into account
      when determining if it matches a selector for the purposes of this
      attribute.)</p>

     <p>If an <a href="#element"><code
      title=attr-binding-element>element</code></a> attribute contains an
      invalid selector, it is <a href="#in-error">in error</a> and must be <a
      href="#ignoring" title=ignore>ignored</a>, meaning that while the
      binding is still parsed and may be referenced using other attachment
      mechanisms, the binding is not attached to any element by its <a
      href="#element"><code title=attr-binding-element>element</code></a>
      attribute, as if the attribute had simply been omitted.</p>
   </dl>

   <div class=note>
    <p>The <a href="#binding0"><code>binding</code></a> element defines a
     presentation and behavior binding. It does not define an element's
     semantics. If an element has no semantics when processed alone, then it
     has no semantics when processed with XBL.</p>

    <p>Sending markup that does not have well-defined semantics over the
     network is bad practice. XBL is intended to be used to augment the user
     experience, for instance by providing better quality widgets or
     enhancing aesthetics. If the document being sent is <em>unusable</em>
     without XBL, then XBL is being abused.</p>
   </div>

   <div class=example id=binding-element-example>
    <p>This binding extends a binding defined in an external file. The
     binding in the other file defines a <code title="">value</code>
     property, and fires events when that property is changed. <em>This</em>
     binding just implements a check box that all <code>div</code> elements
     with the class "<code title="">checkbox</code>" will be bound to.</p>

    <pre>&lt;binding element="div.checkbox" id="checkbox"
         extends="http://www.example.org/resources/ui-core.xml#valuedControl">
 &lt;template>
  &lt;style scoped>
   #wrapper > div { display: inline-block; }
  &lt;/style>
  &lt;div id="wrapper">
   &lt;div id="control">&lt;/div>
   &lt;div id="label">&lt;content>&lt;/content>&lt;/div>
  &lt;/div>
 &lt;/template>
 &lt;implementation>
  ({ xblBindingAttached: function () {
       this.addEventListener('click', function () {
         if (this.baseBinding.value == 'on')
           this.baseBinding.value = 'off';
         else
           this.baseBinding.value = 'on';
       }, false);
       this.addEventListener('change', function () {
         if (this.baseBinding.value == 'on')
           this.shadowTree.getElementById('control').textContent = '&#x2611;';
         else
           this.shadowTree.getElementById('control').textContent = '&#x2610;';
       }, false);
     } })
 &lt;/implementation>
&lt;/binding></pre>
   </div>

   <h3 id=the-implementation-element><span class=secno>2.2. </span>The <dfn
    id=implementation><code>implementation</code></dfn> Element</h3>

   <dl>
    <dt>Expected context:

    <dd><a href="#binding0"><code>binding</code></a>

    <dt>Expected children:

    <dd>If the element has no <a href="#src"><code
     title=attr-implementation-src>src</code></a> attribute: JavaScript text.

    <dd>If the element does have a <a href="#src"><code
     title=attr-implementation-src>src</code></a> attribute: none.
   </dl>

   <p class=note>The <a
    href="#implementation"><code>implementation</code></a> element describes
    a set of methods, properties, and fields that are attached to the bound
    element. Once the binding is attached, these methods, properties, and
    fields can be invoked directly from the bound element.</p>

   <p>The <a href="#implementation"><code>implementation</code></a> element,
    if present, must either contain JavaScript code, or have a <a
    href="#src"><code title=attr-implementation-src>src</code></a> attribute
    that points to a JavaScript file. (See: <a
    href="#binding-implementations0">binding implementations</a>.)</p>

   <h4 class="no-toc no-num" id=attributes0>Attributes</h4>

   <dl>
    <dt>Global attributes

    <dd>Any of HTML's global attributes.

    <dt><dfn id=src title=attr-implementation-src>src</dfn>

    <dd>The <a href="#src"><code title=attr-implementation-src>src</code></a>
     attribute specifies the <a href="#attributes-containing-uris0">URI</a>
     to a JavaScript resource. If the attribute is specified, the contents of
     the element must be ignored (even if the resource could not be fetched
     or was of the wrong type). (See: <a
     href="#binding-implementations0">binding implementations</a>.)
   </dl>

   <p>If the <a href="#implementation"><code>implementation</code></a>
    element points (using the <a href="#src"><code
    title=attr-implementation-src>src</code></a> attribute) to a resource
    that is unavailable, then it is <a href="#in-error">in error</a> and the
    UA must <a href="#ignoring">ignore</a> it, meaning it must not be used as
    an implementation definition for any binding.</p>

   <p><a href="#implementation"><code>implementation</code></a> blocks are
    evaluated once, on first use. Changes to an <a
    href="#implementation"><code>implementation</code></a> element or its
    contents have no effect once the element has been evaluated. (See: <a
    href="#loading-and-running-scripts0">loading and running scripts</a>, <a
    href="#binding-implementations0">binding implementations</a>.)</p>

   <div class=example id=implementation-element-example>
    <p>The following example shows a binding that defines a new method, two
     new properties (one with a custom getter and setter, one without), an
     internal field (used to back the property), and some hooks to initialize
     the binding and to handle the bound element being inserted and removed
     from the document. The binding applies to any element with the class
     "demo" (in the files into which it is imported, that is).</p>

    <pre>
&lt;binding element=".demo">
  &lt;implementation>
   ({
      add: function (op1, op2) {
        return op1+op2;
      },
      get memory() {
        return this._memory.toString();
      },
      set memory(value) {
        this._memory = parseInt(value, 10);
      },
      xblBindingAttached: function() {
        this._memory = 0; // internal property to back "memory" external property
        this.external.state = 'initialized'; // external property
      },
      xblEnteredDocument: function() {
        this.external.state = 'in document';
      },
      xblLeftDocument: function() {
        this.external.state = 'out of document';
      },
   })
  &lt;/implementation>
&lt;/binding></pre>

    <p>The following example shows how to refer to an external file for the
     implementation of a binding. This is the same binding as the previous
     example.</p>

    <pre>&lt;binding element=".demo">
 &lt;implementation src="demo.js">&lt;/implementation>
&lt;/binding></pre>

    <p>The <code>demo.js</code> file would look like this:</p>

    <pre>({
   add: function (op1, op2) {
     return op1+op2;
   },
   get memory() {
     return this._memory.toString();
   },
   set memory(value) {
     this._memory = parseInt(value, 10);
   },
   xblBindingAttached: function() {
     this._memory = 0; // internal property to back "memory" external property
     this.external.state = 'initialized'; // external property
   },
   xblEnteredDocument: function() {
     this.external.state = 'in document';
   },
   xblLeftDocument: function() {
     this.external.state = 'out of document';
   },
})</pre>
   </div>

   <h3 id=the-template-element><span class=secno>2.3. </span>The <dfn
    id=template><code>template</code></dfn> Element</h3>

   <dl>
    <dt>Expected context:

    <dd><a href="#binding0"><code>binding</code></a>

    <dt>Expected children:

    <dd>Anything. Of particular interest, the <a
     href="#content"><code>content</code></a> and <a
     href="#inherited"><code>inherited</code></a> elements may occur as
     descendants, and non-XBL descendant elements may host <a
     href="#attributes4"><code title=attr-attributes>attributes</code></a>
     and <a href="#pseudo"><code title=attr-pseudo>pseudo</code></a>
     attributes.
   </dl>

   <p class=note>The <a href="#template"><code>template</code></a> element
    contains arbitrary element descendants. When a binding is attached, the
    <a href="#template"><code>template</code></a> element's child nodes are
    cloned and attached to the bound document under the bound element.
    Dynamic changes to the descendants of <a
    href="#template"><code>template</code></a> elements are reflected in
    bindings. (See: <a href="#shadow-content0">shadow content</a>.)</p>

   <h4 class="no-toc no-num" id=attributes1>Attributes</h4>

   <dl>
    <dt>Global attributes

    <dd>Any of HTML's global attributes.

    <dt><dfn id=apply-author-sheets
     title=attr-template-apply-author-sheets>apply-author-sheets</dfn>

    <dd>The <a href="#apply-author-sheets"><code
     title=attr-template-apply-author-sheets>apply-author-sheets</code></a>
     attribute indicates whether or not rules in <a
     href="#author-style-sheets">author style sheets</a> associated with the
     bound element's document apply to the shadow content generated by the
     binding. Its value must be either <code>true</code> (indicating that
     they do) or <code>false</code> (indicating that they do not). The
     default behavior, which is used when the attribute is omitted or has a
     value other than the two allowed values, is to not apply the bound
     document's <a href="#author-style-sheets">author style sheets</a> (same
     as <code>false</code>). (See: <a href="#binding-style-sheets0">binding
     style sheets</a>.)

    <dt><dfn id=allow-selectors-through
     title=attr-template-allow-selectors-through>allow-selectors-through</dfn>

    <dd>The <a href="#allow-selectors-through"><code
     title=attr-template-allow-selectors-through>allow-selectors-through</code></a>
     attribute indicates whether or not rules in CSS can <a
     href="#selectors-and-shadow-scopes0" title="selectors and shadow
     scopes">cross scopes</a>. Its value must be either <code>true</code>
     (indicating that they can) or <code>false</code> (indicating that they
     cannot). The default behavior, which is used when the attribute is
     omitted or has a value other than the two allowed values, is to not let
     selectors cross scopes (same as <code>false</code>). (See: <a
     href="#selectors-and-shadow-scopes0">selectors and shadow scopes</a>.)
   </dl>

   <p class=note>The semantics of non-XBL elements inside this element are
    untouched, which can lead to unintuitive results. (See: <a
    href="#shadow-content-and-other-things0">semantics of non-XBL elements in
    XBL contexts</a>.)</p>

   <div class=example id=template-element-example>
    <p>The following binding defines a shadow tree that wraps the contents of
     the bound element in four blocks. It uses the <a
     href="#apply-author-sheets"><code
     title=attr-template-apply-author-sheets>apply-author-sheets</code></a>
     attribute to allow the bound document to style the nodes directly, and
     uses the <a href="#allow-selectors-through"><code
     title=attr-template-allow-selectors-through>allow-selectors-through</code></a>
     attribute to allow the bound document to pretend (for the purposes of
     selector matching) that the shadow tree actually is descended from the
     bound element.</p>

    <pre>&lt;binding id="wrapBy4">
 &lt;template apply-author-sheets="true" allow-selectors-through="true">
  &lt;div class="wrap1">
   &lt;div class="wrap2">
    &lt;div class="wrap3">
     &lt;div class="wrap4">
      &lt;content>&lt;/content>
     &lt;/div>
    &lt;/div>
   &lt;/div>
  &lt;/div>
 &lt;/template>
&lt;/binding></pre>

    <p>Using this binding could take the following document:</p>

    <pre>&lt;DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Pretty Title&lt;/title>
  &lt;style>
   h1 span { display: block; }
   h1 { border: solid red; }
   h1 .wrap1 { border: solid orange; }
   h1 .wrap2 { border: solid yellow; }
   h1 .wrap3 { border: solid green; }
   h1 .wrap4 { border: solid blue; }
  &lt;/style>
 &lt;/head>
 &lt;body>
  &lt;h1>
   &lt;span class="wrap1">
    &lt;span class="wrap2">
     &lt;span class="wrap3">
      &lt;span class="wrap4">
       Pretty Title
      &lt;/span>
     &lt;/span>
    &lt;/span>
   &lt;/span>
  &lt;/h1>
  ...
 &lt;/body>
&lt;/html></pre>

    <p>...and shrink it to this:</p>

    <pre>&lt;DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;title>Pretty Title&lt;/title>
  &lt;style>
   h1 { binding: url(cool.xml#wrapBy4); }
   h1 { border: solid red; }
   h1 .wrap1 { border: solid orange; }
   h1 .wrap2 { border: solid yellow; }
   h1 .wrap3 { border: solid green; }
   h1 .wrap4 { border: solid blue; }
  &lt;/style>
 &lt;/head>
 &lt;body>
  &lt;h1>Pretty Title&lt;/h1>
  ...
 &lt;/body>
&lt;/html></pre>

    <p>...which removes the semantic-free elements used as presentation hooks
     from the content markup layer, and places them in the presentation layer
     where they belong.</p>
   </div>

   <h3 id=the-content-element><span class=secno>2.4. </span>The <dfn
    id=content><code>content</code></dfn> Element</h3>

   <dl>
    <dt>Expected context:

    <dd>Any, but there must be a <a href="#correct">correct</a> <a
     href="#template"><code>template</code></a> element somewhere in the
     ancestor chain, and there must not be any <a
     href="#content"><code>content</code></a> elements anywhere in the
     ancestor chain.

    <dt>Expected children:

    <dd>Anything.</dd>
--><!-- transparent --><!--
   </dl>

   <div class=note>
    <p>The <a href="#content"><code>content</code></a> element is used inside
     <a href="#shadow-content0">shadow content</a> to specify where <a
     href="#explicit-children">explicit children</a> that might already exist
     underneath the bound element are inserted into the <a
     href="#shadow-tree">shadow tree</a>. As far as the presentation model is
     concerned, any shadow content the binding places between the bound
     element and the <a href="#content"><code>content</code></a> elements is
     interleaved between the bound element and its <a
     href="#explicit-children">explicit children</a> without affecting the
     document model.</p>

    <p>If the <a href="#includes"><code
     title=attr-content-includes>includes</code></a> attribute has children
     of the bound element assigned to it, then those children are inserted
     into the <a href="#final-flattened-tree">final flattened tree</a> in
     place of the <a href="#content"><code>content</code></a> element.
     Otherwise, the child elements of the <a
     href="#content"><code>content</code></a> element are inserted into the
     <a href="#final-flattened-tree">final flattened tree</a> in place of the
     <a href="#content"><code>content</code></a> element instead. (See: <a
     href="#processing-content-elements0">processing <code
     title="">content</code> elements</a>.)</p>
   </div>

   <h4 class="no-toc no-num" id=attributes2>Attributes</h4>

   <dl>
    <dt>Global attributes

    <dd>Any of HTML's global attributes.

    <dt><dfn id=includes title=attr-content-includes>includes</dfn>

    <dd>The <a href="#includes"><code
     title=attr-content-includes>includes</code></a> attribute can be used to
     indicate that only certain content should be placed at the <a
     href="#content"><code>content</code></a> element. Its value must be a
     valid <a href="#attributes-containing-selectors0">selector</a>. (See: <a
     href="#processing-content-elements0">processing <code
     title="">content</code> elements</a>.)

    <dt><dfn id=apply-binding-sheets
     title=attr-content-apply-binding-sheets>apply-binding-sheets</dfn>

    <dd>The <a href="#apply-binding-sheets"><code
     title=attr-content-apply-binding-sheets>apply-binding-sheets</code></a>
     attribute indicates whether or not scoped style sheets loaded for an XBL
     binding are applied to a bound element's <a
     href="#explicit-children">explicit children</a> (in addition to the
     bound element itself) that are inserted below this <a
     href="#content"><code>content</code></a> element when it is processed.
     Its value must be either <code>true</code> (indicating that they are) or
     <code>false</code> (indicating that they are not). The default behavior,
     which is used when the attribute is omitted or has a value other than
     the two allowed values, is that they are not applied (same as
     <code>false</code>). (See: <a href="#binding-style-sheets0">binding
     style sheets</a>.)

    <dt><dfn id=locked title=attr-content-locked>locked</dfn>

    <dd>The <a href="#locked"><code
     title=attr-content-locked>locked</code></a> attribute indicates whether
     or not new children may be inserted below this <a
     href="#content"><code>content</code></a> element when it is processed.
     Its value must be either <code>true</code> (indicating that they may
     not) or <code>false</code> (indicating that they may). The default
     behavior, which is used when the attribute is omitted or has a value
     other than the two allowed values, is that they may be inserted (same as
     <code>false</code>). Elements already assigned to a <a
     href="#content"><code>content</code></a> element whose <a
     href="#locked"><code title=attr-content-locked>locked</code></a>
     attribute is dynamically changed are not removed from that element.
     (See: <a href="#processing-content-elements0">processing <code
     title="">content</code> elements</a>.)
   </dl>

   <div class=example id=content-element-example>
    <p>This sample extract from a binding document shows how to use the <a
     href="#includes"><code title=attr-content-includes>includes</code></a>
     attribute to distribute children to different parts of a shadow content
     template.</p>

    <pre>&lt;binding element=".grid">
 &lt;template>
  &lt;div class="caption" attributes="text=title">&lt;/div>
  &lt;div class="outer-table">
   &lt;div class="columns">
    &lt;content includes=".column">
     &lt;!-- default to have just one column if none are declared --&gt;
     &lt;div class="column">&lt;/div>
    &lt;/content>
   &lt;/div>
   &lt;div class="rows">
    &lt;content includes=".heading">&lt;/content>
    &lt;div class="body">
     &lt;content includes=".row:not([hidden])">&lt;/content>
    &lt;/div>
   &lt;/div>
  &lt;/div>
 &lt;/template>
 ...
&lt;/binding></pre>

    <p>The above template would be used with markup such as the following:</p>

    <pre>&lt;div class=grid title="The Lesser of Two Evils">
 &lt;div class=column id="product" sort="alphabetic primary"></pre>
   </div>
   &lt;div class=column id="catchphrase" sort="alphabetic secondary"></div>

  <p> &lt;div class=heading> &lt;div class=item>Product&lt;div> &lt;div
   class=item>Catchphrase&lt;div> &lt;div> &lt;div class=row> &lt;div
   class=item>Arachno Spores&lt;div> &lt;div class=item>The fatal spore with
   the funny name&lt;div> &lt;div> &lt;div class=row> &lt;div
   class=item>Pastorama&lt;div> &lt;div class=item>Located on the former site
   of Brooklyn&lt;div> &lt;div> &lt;div>

  <p>The following illustrates how the above markup would get redistributed.

  <p><img alt="The two class=column divs would get put under the
   class=columns div in the template; the class=heading div and its
   descendants would end up at the start of the class=rows div, and the two
   class=row elements would end up under the div with class=body."
   src="images/content-element-example-explanation.png">

  <div class=example id=content-element-example-2>
   <p>In this example, the binding uses the <a
    href="#apply-binding-sheets"><code
    title=attr-content-apply-binding-sheets>apply-binding-sheets</code></a>
    attribute to let its stylesheet affect the <a
    href="#explicit-children">explicit children</a> of the bound element.</p>

   <pre>
&lt;binding element=".listbox">
 &lt;template allow-selectors-through="true">
  &lt;style scoped>
   .listbox { display: block; background: white; color: black; }
   .listbox > div#listbox-focus { border: ridge silver; }
   .listbox:focus > div#listbox-focus { border: inset silver; }
   .listitem { display: block; background: white; color: black; }
   .listitem[data-selected] { display: block; background: navy; color: white;}
  &lt;/style>
  &lt;div id="listbox-focus">
   &lt;content includes=".listitem" apply-binding-sheets="true">&lt;/content>
  &lt;/div>
 &lt;/template>
 &lt;implementation>
  ...
 &lt;/implementation>
&lt;/binding></pre>
  </div>

  <div class=example id=content-element-example-locked>
   <p>In the following example, the <a href="#locked"><code
    title=attr-content-locked>locked</code></a> attribute is used to keep the
    children of the bound element in the location that the user has selected.
    By default, the <code title="">li</code> elements would be placed in the
    first <a href="#content"><code>content</code></a> element, but because it
    is locked, they will instead go into the second one. (This example
    assumes that there is also a binding for the "<code
    title="">selectableList</code>" class that defines a <code
    title="">.selectedElement</code> IDL attribute.)</p>

   <pre>&lt;binding element="ul.split">
 &lt;template>
  &lt;div>
   &lt;ul id="left" title="Selected Items" class="selectableList">
    &lt;content includes="li" locked="true" id="leftList">&lt;/content>
   &lt;/ul>
  &lt;/div>
  &lt;div id="buttons">
   &lt;button id="move-right"> Move Right &lt;/button>
   &lt;button id="move-left"> Move Left &lt;/button>
  &lt;/div>
  &lt;div>
   &lt;ul id="right" title="Available Items" class="selectableList">
    &lt;content includes="li" id="rightList">&lt;/content>
   &lt;/ul>
  &lt;/div>
 &lt;/template>
 &lt;implementation>
  ({
    xblBindingAttached: function() {
      this.shadowTree.getElementById('move-right').addEventListener(
        'click', this.moveRight, false
      );
      this.shadowTree.getElementById('move-left').addEventListener(
        'click', this.moveLeft, false
      );
    },
    moveRight: function(event) {
      this.shadowTree.getElementById('rightList').setInsertionPoint(
        this.shadowTree.getElementById('left').selectedElement
      );
    },
    moveLeft: function(event) {
      this.shadowTree.getElementById('leftList').setInsertionPoint(
        this.shadowTree.getElementById('right').selectedElement
      );
    },
  })
 &lt;/implementation>
&lt;/binding></pre>
  </div>

  <h3 id=the-inherited-element><span class=secno>2.5. </span>The <dfn
   id=inherited><code>inherited</code></dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd>Any, but there must be a <a href="#correct">correct</a> <a
    href="#template"><code>template</code></a> element somewhere in the
    ancestor chain.

   <dt>Expected children:

   <dd>Anything.
  </dl>

  <p class=note>The <a href="#inherited"><code>inherited</code></a> element
   represents where the next inherited shadow tree is to be inserted. If the
   binding is the base binding (and thus has no inherited bindings) or if
   none of the bindings it inherits from have shadow trees, or if this is not
   the first <a href="#inherited"><code>inherited</code></a> element in the
   binding's shadow tree, then the contents of the <a
   href="#inherited"><code>inherited</code></a> element (if any) will be used
   instead. (See: <a href="#final-flattened-tree" title="final flattened
   tree">the final flattened tree</a>.)

  <h4 class="no-toc no-num" id=attributes3>Attributes</h4>

  <dl>
   <dt>Global attributes

   <dd>Any of HTML's global attributes.
  </dl>

  <p class=note>While it is legal to nest <a
   href="#inherited"><code>inherited</code></a> elements, it is pointless,
   since if one <a href="#inherited"><code>inherited</code></a> element used
   its fallback content, any subsequent such elements will too.

  <div class=example id=inherited-element-example>
   <p>The following binding wraps the bound element's children in a set of
    <code>div</code>s for extra styling. By using the <a
    href="#inherited"><code>inherited</code></a> element, it has been
    designed such that it must be used in conjunction with other bindings: it
    will (if applied after the others) wrap the shadow trees of those
    templates. Contrast this with <a href="#template-element-example">the
    example in the <code>template</code> section</a>, which would not
    interact with other bindings. However, if this binding is not applied in
    conjunction with a binding that has a <a
    href="#content"><code>content</code></a> element giving a place for the
    element's explicit children, then those children will not be in the final
    flattened tree.</p>

   <pre>&lt;binding id="wrapBy4">
 &lt;template apply-author-sheets="true" allow-selectors-through="true">
  &lt;div class="wrap1">
   &lt;div class="wrap2">
    &lt;div class="wrap3">
     &lt;div class="wrap4">
      &lt;inherited>&lt;/inherited>
     &lt;/div>
    &lt;/div>
   &lt;/div>
  &lt;/div>
 &lt;/template>
&lt;/binding></pre>
  </div>

  <h3 id=the-attributes-attribute><span class=secno>2.6. </span>The <dfn
   id=attributes4 title=attr-attributes><code>attributes</code></dfn>
   Attribute</h3>

  <dl>
   <dt>Expected element:

   <dd>Any, but there must be a <a href="#correct">correct</a> <a
    href="#template"><code>template</code></a> element somewhere in the
    ancestor chain.
  </dl>

  <p class=note>The <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attribute is a global
   attribute that specifies which attributes on the bound element should be
   forwarded to the element on which the attribute is found when the shadow
   content template is cloned. It is a <a
   href="#attributes-containing-space-separated-va0">space-separated</a> list
   of pairs of attribute names separated by equal signs, each possibly
   suffixed by a hash character ("#") and a type designation. (See: <a
   href="#attribute-forwarding0">attribute forwarding</a>.)

  <p>The value of the <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attribute must be a <a
   href="#attributes-containing-space-separated-va0">space-separated</a>
   value of items that match the pattern given in the <a
   href="#attribute-forwarding0">attribute forwarding</a> section.

  <div class=example id=inherits-attribute-example>
   <p>One of the major uses of the <a href="#attributes4"><code
    title=attr-attributes>attributes</code></a> attribute is to implement one
    element in terms of another element which already has special behavior in
    user agents. This example shows how an element can be implemented in
    terms of an HTML <code>input</code> element, with certain attributes
    being forwarded to that element directly.</p>

   <pre>&lt;binding element=".uitext">
 &lt;template>
  &lt;label>
   &lt;span attributes="*text=data-label"/>
   &lt;input attributes="value=data-default disabled=data-disabled readonly=data-readonly" id="input">
  &lt;/label>
 &lt;/template>
 &lt;implementation>
  ({
   get value () { return this.shadowTree.getElementById('input').value; },
   set value (val) { this.shadowTree.getElementById('input').value = val; },
  })
 &lt;/implementation>
&lt;/binding></pre>

   <p>Here is how this binding could be used:</p>

   <pre>&lt;div data-label="Location" data-default="County Down">&lt;/div></pre>

   <p>Of course, it would be far more usable and accessible (not to mention
    having better fallback when scripts are disabled) if the page just used
    <code>input</code> directly!</p>
  </div>

  <h3 id=the-pseudo-attribute><span class=secno>2.7. </span>The <dfn
   id=pseudo title=attr-pseudo><code>pseudo</code></dfn> Attribute</h3>

  <dl>
   <dt>Expected element:

   <dd>Any, but there must be a <a href="#correct">correct</a> <a
    href="#template"><code>template</code></a> element somewhere in the
    ancestor chain.
  </dl>

  <p class=note>The <a href="#pseudo"><code
   title=attr-pseudo>pseudo</code></a> attribute is a global attribute that
   specifies the <a href="#pseudo-element">pseudo-element</a> that, when used
   on the bound element, must be mapped to the element on which the attribute
   is found.

  <p>The value of the <a href="#pseudo"><code
   title=attr-pseudo>pseudo</code></a> attribute must be a valid <a
   href="#pseudo-element">pseudo-element</a> name, in lowercase, without the
   leading "::". The valid pseudo-elements are defined by the CSS
   specifications, and are "value", "choices", "label", "repeat-item", and
   "icon". Future versions of CSS might introduce new values. (See: <a
   href="#matching-pseudo-elements0">matching pseudo-elements</a>.)

  <div class=example id=pseudo-attribute-example>
   <p>The <a href="#pseudo"><code title=attr-pseudo>pseudo</code></a>
    attribute is useful as a way to let <a href="#author-style-sheets"
    title="author style sheets">author styles</a> affect the insides of a
    shadow tree without exposing the exact construction of the tree. Here,
    the binding represents a composite widget with an icon, a label, a text
    field, and some buttons. Pseudo-elements are used for each part allowing
    the author to style each part separately.</p>

   <pre>&lt;binding id="input-dialog">
 &lt;template>
  &lt;div class="root">
   &lt;div class="icon-block">
    &lt;img pseudo="icon" attributes="src=icon alt=alt">
   &lt;/div>
   &lt;div pseudo="label" attributes="*text=label">&lt;/div
   &lt;div class="field-block">
    &lt;input pseudo="value" attributes="value" id="field">
   &lt;/div>
   &lt;div class="buttons-block">
    &lt;button pseudo="choices" id="ok"> OK &lt;/button>
    &lt;button pseudo="choices" id="cancel"> Cancel &lt;/button>
   &lt;/div>
  &lt;/div>
 &lt;/template>
 ...
&lt;/binding></pre>

   <p>An author-level stylesheet for a document using the binding might look
    like:</p>

   <pre>.textDialog { binding: url(dialogs.xbl#input-dialog); }
.textDialog::value { background: white; color: black; }
textDialog::choices { border: outset; }</pre>
  </div>
-->
<!-- FIXME: Needs update.
  <h2 id=binding-attachment-and-detachment><span class=secno>3. </span><dfn
   id=binding-attachment-and-detachment0>Binding Attachment and
   Detachment</dfn></h2>

  <p>Bindings can be attached and detached dynamically, using several
   mechanisms.

  <p>Bindings must be attached as soon as the following conditions have all
   been met:

  <ul>
   <li>it is known that the binding applies to the element,

   <li>the DOM <code>Element</code> object for the element has been created,
    and

   <li>the binding document defining the binding has loaded.
  </ul>

  <p>In particular, binding can happen before the element is inserted into
   its document.

  <p>If the binding document was already loaded when the element was created,
   or when it became known that the element matched the binding (e.g. because
   the binding's <a href="#element"><code
   title=attr-binding-element>element</code></a> attribute is mutated in a
   script), then the binding must be applied such that to any running
   scripts, notwithstanding those implementing <a
   href="#xblbindingattached"><code>xblBindingAttached()</code></a>
   notification methods, it appears that the binding was applied immediately.
   When mutation events are to fire, they must fire <em>after</em> the
   binding being applied.

  <p>If the binding document has yet to be (fully) loaded when it becomes
   known that the binding applies, then the user agent must wait until all
   running scripts have completed before attaching the binding.</p>
  --><!-- XXX define this in terms of event loops --><!--

  <p class=note>If the binding attachment mechanism is the <a
   href="#binding1"><code title="binding property">'binding'</code></a>
   property, then it does not become known to the user agent that the binding
   applies (or does not apply) until the next time style resolution is
   performed. This specification does not define when style resolution
   happens.</p>
  --><!-- XXX who does. HTML5? --><!--

  <div class=example>
   <p>Assume that <code title="">foo.xbl</code> defines a binding that
    applies to all "<code title="">foo</code>" elements. The following script
    uses <a href="#loadbindingdocument"><code
    title=loadBindingDocument>loadBindingDocument()</code></a> to ensure that
    <code title="">foo.xbl</code> is loaded, then creates a <code
    title="">foo</code> element and uses it.</p>

   <pre>// load the binding document
document.loadBindingDocument('foo.xbl').onload = function () {
  // create an element &lt;foo>
  var foo = document.createElement('foo'); // binds synchronously
  foo.myCustomMethod(); // calls the binding's implementation
};</pre>
  </div>

  <p>Bindings must be detached as soon as it is known that the binding no
   longer applies to the element. In the case of attachment using the '<a
   href="#binding1"><code title="binding property">binding</code></a>'
   property, this won't be until the next time style resolution is performed.

  <p>When it becomes known that a binding is to be detached, it must happen
   such that to any running scripts it appears that the binding was removed
   immediately, except if the script in question is running as part of the
   last step of the binding attachment process, in which case the detachment
   happens after all the bindings being attached have had their methods
   called. (See: <a href="#binding-attachment-model0">binding attachment
   model</a>.)</p>
  --><!-- XXX this contradicts what is said elsewhere; could make this
  work by saying "except if there is an xblFoo notification method
  running" or something --><!--

  <h3 id=the-bindings-are-ready-state><span class=secno>3.1. </span><dfn
   id=the-bindings-are-ready-state0>The Bindings-Are-Ready State</dfn></h3>

  <p>XBL implementations must have a <dfn
   id=bindings-are-ready>bindings-are-ready</dfn> counter (for each
   <code>Document</code>) that keeps track of when there are outstanding
   bindings to bind. This counter is set at the times given in the following
   sections. (It is not set for all kinds of attachments.)

  <p>If the bound document is being parsed by the user agent, then, as soon
   as all the following conditions have been met, the user agent must fire an
   <dfn id=xbl-bindings-are-ready><code>xbl-bindings-are-ready</code></dfn>
   event on the document's root element. The conditions are:

  <ul>
   <li> the document has finished parsing,

   <li> the <a href="#bindings-are-ready">bindings-are-ready</a> counter is
    at zero,

   <li> all bindings that are known to apply to elements have been completely
    applied, and

   <li> no scripts are running.
  </ul>

  <p>The event must use the <code>Event</code> interface, must bubble, must
   not be cancelable, and must not have a default action. <a
   href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  <p>Initially, the <a href="#bindings-are-ready">bindings-are-ready</a>
   counter must be set to zero.

  <p>The bound document's <code>load</code> event must not fire until after
   the <a
   href="#xbl-bindings-are-ready"><code>xbl-bindings-are-ready</code></a>
   event has fired. The <a
   href="#xbl-bindings-are-ready"><code>xbl-bindings-are-ready</code></a>
   event must fire even in the complete absence of any use of XBL in the
   document.

  <p>The <a
   href="#xbl-bindings-are-ready"><code>xbl-bindings-are-ready</code></a>
   event must only fire once per document load.

  <h3 id=attachment-using-ltbinding-elementgt><span class=secno>3.2.
   </span><dfn id=attachment-using-ltbinding-elementgt0 title="attachment
   using binding">Attachment using <code title=binding>&lt;binding
   element=""&gt;</code></dfn></h3>

  <p>The simplest binding mechanism is the <a
   href="#binding0"><code>binding</code></a> element's <a
   href="#element"><code title=attr-binding-element>element</code></a>
   attribute. It declares which bindings should be attached to which
   elements. (See: <a href="#attributes-containing-selectors0"
   title=selector>attributes containing selectors</a>, <a href="#element"
   title=attr-binding-element>the <code title="">binding</code> element</a>.)

  <p>While an element matches the <a href="#element"><code
   title=attr-binding-element>element</code></a> attribute of one or more of
   the <a href="#binding0"><code>binding</code></a> elements that is <a
   href="#importing-binding-documents0" title=import>imported</a> into, or
   defined in, the element's document, the bindings defined by each such <a
   href="#binding0"><code>binding</code></a> element must be bound to the
   element. This applies to all elements that are associated with a document,
   even when they have not yet been inserted into the document, or are not in
   the <a href="#final-flattened-tree">final flattened tree</a>.

  <h4 id=importing-binding-documents><span class=secno>3.2.1. </span><dfn
   id=importing-binding-documents0 title=import>Importing Binding
   Documents</dfn></h4>

  <p>There are two ways to import binding documents (and thus have their <a
   href="#binding0"><code title=binding>&lt;binding element=""&gt;</code></a>
   bindings apply): <a href="#the-ltxblgt-processing-instruction"
   title=xbl-pi>the <code>&lt;?xbl?&gt;</code> processing instruction</a>,
   and the <a
   href="#loadbindingdocument"><code>loadBindingDocument()</code></a> method.
   The latter is defined in the section on the <a
   href="#documentxbl"><code>DocumentXBL</code></a> interface.

  <p><dfn id=the-ltxblgt-processing-instruction title=xbl-pi>The
   <code>&lt;?xbl?&gt;</code> processing instruction</dfn> specifies a
   binding document to load. Any bindings <a
   href="#attachment-using-ltbinding-elementgt0" title="attachment using
   binding">defined in that document</a> must be applied to matching elements
   in the document with the processing instruction.

  <p><code>&lt;?xbl?&gt;</code> processing instructions that occur after the
   root element's start tag in the markup are <a href="#in-error">in
   error</a>. <code>&lt;?xbl?&gt;</code> PIs that are dynamically inserted
   through the DOM after the root element's start tag has been parsed or the
   root element has been attached to the document are <a href="#in-error">in
   error</a> too.

  <p>A <code>&lt;?xbl?&gt;</code> processing instruction that is not <a
   href="#in-error">in error</a> according to the above must be parsed using
   the same syntax as the XML Stylesheet PI. <a
   href="#refsXMLSSPI">[XMLSSPI]</a> If there are any parse errors, then the
   entire processing instruction is <a href="#in-error">in error</a>.

  <p>Otherwise, if it has an <dfn id=href
   title=attr-import-href><code>href</code></dfn> pseudo-attribute then it
   specifies the <a href="#attributes-containing-uris0">URI</a> of the
   binding document to import. If the URI cannot be resolved, or returns an
   error, or does not point to a resource with <span>an XML MIME
   type</span>--><!-- XXX
  xref --><!--, or has any other problem that makes it
   unusable, then the processing instruction is <a href="#in-error">in
   error</a>.

  <p>If a processing instruction is <a href="#in-error">in error</a> (as
   described in the previous few paragraphs) then it must be ignored.

  <p>Otherwise, the referenced document must be loaded (unless it has <a
   href="#loading-external-resources0" title="loading external
   resources">already been loaded</a>), and any bindings defined by that
   document must be applied to matching elements in the document that
   contained the PI. Once loaded, the binding document is added to the <a
   href="#bindingdocuments"><code>bindingDocuments</code></a> list of the
   document with the PI.

  <p>Dynamic changes to <code>&lt;?xbl?&gt;</code> processing instructions
   must be ignored from an XBL standpoint.

  <p>An imported binding document is <em>live</em>.

  <p class=example>For example, if new <a
   href="#binding0"><code>binding</code></a> elements are added to an
   imported binding document (via the DOM), then the new bindings are
   immediately applied to the document that had the PI importing that binding
   document.

  <p>XBL bindings are always implicitly imported into the document in which
   they are defined.

  <p>Whenever an <code>&lt;?xbl?></code> PI causes a binding document to be
   loaded, the document's <a
   href="#bindings-are-ready">bindings-are-ready</a> counter must be
   increased by one. Once the binding document is loaded, the counter must be
   decreased by one.

  <div class=example>
   <p>A <a href="#binding0"><code>binding</code></a> element that defines a
    binding is automatically imported in the element's owner document, so
    such mappings are always used. The following example demonstrates this.</p>

   <pre><strong>example.xml</strong>

&lt;...&gt;
 &lt;binding element="foo" xmlns="http://www.w3.org/1999/xhtml"&gt;
  ...
 &lt;/binding&gt;
 &lt;binding element="bar" xmlns="http://www.w3.org/1999/xhtml"&gt;
  ...
 &lt;/binding&gt;
 &lt;foo/&gt; &lt;!-- this will have a binding applied --&gt;
 &lt;bar/&gt; &lt;!-- this will have a binding applied --&gt;
&lt;/...&gt;
</pre>

   <p>If the binding definitions are in a separate file, then that file needs
    to be imported explicitly:</p>

   <pre><strong>widgets.xml</strong>

&lt;...&gt;
 &lt;binding element="foo" xmlns="http://www.w3.org/1999/xhtml"&gt;
  ...
 &lt;/binding&gt;
 &lt;binding element="bar" xmlns="http://www.w3.org/1999/xhtml"&gt;
  ...
 &lt;/binding&gt;
&lt;/...&gt;
</pre>

   <pre><strong>example.xml</strong>

<em>&lt;?xbl href="widgets.xbl"?&gt;</em>
&lt;...&gt;
 &lt;foo/&gt; &lt;!-- bound --&gt;
 &lt;bar/&gt; &lt;!-- bound --&gt;
&lt;/...&gt;
</pre>

   <p>If a file imports some bindings and the file containing those bindings
    has its own <code>&lt;?xbl?&gt;</code> processing instructions, that
    second PI only affects nodes in the binding document, not the original
    document. For example:</p>

   <pre><strong>foo.xml</strong>

&lt;...&gt;
 &lt;binding element="foo" xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;content&gt;
   &lt;bar xmlns=""/&gt; &lt;!-- not bound, not even when in shadow content --&gt;
  &lt;/content&gt;
 &lt;/binding&gt;
&lt;/...&gt;
</pre>

   <pre><strong>bar.xml</strong>

&lt;?xbl href="foo.xbl"?&gt;
&lt;...&gt;
 &lt;binding element="bar" xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;content&gt;
   &lt;foo xmlns=""/&gt; &lt;!-- bound: this document imports foo.xml --&gt;
   &lt;bar xmlns=""/&gt; &lt;!-- bound: bar binding is defined locally --&gt;
  &lt;/content&gt;
 &lt;/binding&gt;
&lt;/...&gt;
</pre>

   <pre><strong>example.xml</strong>

&lt;?xbl href="bar.xml"?&gt;
&lt;...&gt;
 &lt;foo/&gt; &lt;!-- not bound: foo.xml not imported here --&gt;
 &lt;bar/&gt; &lt;!-- bound --&gt;
&lt;/...&gt;
</pre>
  </div>

  <h3 id=attachment-using-css><span class=secno>3.3. </span>Attachment using
   CSS</h3>

  <p>Bindings can be attached to elements through CSS using the '<a
   href="#binding1"><code title="binding property">binding</code></a>'
   property.

  <div class=example>
   <p>In the following example, a binding is referenced that will be attached
    to all HTML checkbox elements.</p>

   <pre>
input[type="checkbox"] {
  binding: url("http://www.example.org/res/htmlBindings.xbl#checkbox");
}
</pre>
  </div>

  <p>Bindings attached through CSS must only remain on the bound element as
   long as the element continues to match the style rule. If at any time a
   resolution of style on the element determines that a different binding
   should be attached, the old binding (and all bindings that it explicitly
   extends in its <a href="#explicit-inheritance-chain">explicit inheritance
   chain</a>) must be detached.

  <p>Whenever an element is removed from a document, any bindings attached to
   that element via CSS must be detached.

  <p class=note>Attaching a binding using CSS does not <a
   href="#importing-binding-documents0">import</a> the binding document. The
   <a href="#element"><code title=attr-binding-element>element</code></a>
   attributes of <a href="#binding0"><code>binding</code></a> elements in the
   binding document do not take effect unless the binding document is
   imported. (See: <a href="#importing-binding-documents0"
   title=import>importing binding documents</a>.)

  <p>Attaching using CSS does not affect the <a
   href="#bindings-are-ready">bindings-are-ready</a> counter.

  <h4 id=the-binding-property><span class=secno>3.3.1. </span>The '<a
   href="#binding1"><code title="binding property">binding</code></a>'
   Property</h4>

  <p>A property to attach a binding to a particular element.

  <table class=propdef>
   <caption> <dfn id=binding1 title="binding
    property">'<code>binding</code>'</dfn></caption>

   <tbody>
    <tr>
     <td><em>Value:</em>

     <td>none | [ &lt;uri&gt; ]* &lt;uri&gt;
      --><!--XXXPD &lt;predefined binding&gt;--><!--

    <tr>
     <td><em>Initial:</em>

     <td>none

    <tr>
     <td><em>Applies To:</em>

     <td>all elements (but not pseudo-elements)

    <tr>
     <td><em title="">Inherited:</em>

     <td>no

    <tr>
     <td><em>Percentages:</em>

     <td>n/a

    <tr>
     <td><em>Media:</em>

     <td>all

    <tr>
     <td><em>Computed Value:</em>

     <td>specified value, with URIs resolved to absolute URIs
  </table>

  <dl>
   <dt>none

   <dd>No bindings are to be attached through CSS.

   <dt>&lt;uri&gt;

   <dd>The specified binding is attached. More than one binding can be
    specified, resulting in the bindings being attached in the specified
    order, with the last binding implicitly inheriting from the previous one,
    and so forth, up to the first binding. (See: <a
    href="#binding-inheritance0">binding inheritance</a>.)</dd>
   --><!--XXXPB
   <dt>&lt;predefined binding&gt;</dt>
   <dd>One of the bindings defined in the <a
   href="#base-bindings">Predefined Base Bindings</a> section is
   attached.</dd>
--><!--
  </dl>

  <h4 id=processing-model><span class=secno>3.3.2. </span>Processing Model</h4>

  <p>User agents may perform the CSS cascade, inheritance, and computation
   stages either across the entire tree, or per element, or per property per
   element, and either before applying bindings, or simultaneously, while
   applying bindings. In any case, for each element the computed value of '<a
   href="#binding1"><code title="binding property">binding</code></a>' must
   be found and then used to apply the bindings to the element (when the
   element is first styled, and each subsequent time the styles that match
   the element change).

  <p>Since each time a binding is applied it can change the computed values
   of properties of elements that are descendants of the bound element, this
   may require several passes. This may be avoided by computing the value of
   the '<a href="#binding1"><code title="binding
   property">binding</code></a>' property for the element, and then applying
   any bindings, before any of its descendants.

  <h4 id=examples><span class=secno>3.3.3. </span>Examples</h4>

  <div class=example id=triangles-example>
   <p>The following fragment of XML defines two bindings for use in SVG. The
    first renders an isosceles triangle in place of bound elements that use
    it, the other renders a right-angled triangle in place of bound elements
    that use it.</p>

   <pre>
&lt;...>
 &lt;binding id="isosceles" xmlns="http://www.w3.org/1999/xhtml">
  &lt;template>
   &lt;polygon attributes="transform" points="0 -1, 1 0, -1 0" xmlns="http://www.w3.org/2000/svg"/>
  &lt;/template>
 &lt;/binding>
 &lt;binding id="rightangle" xmlns="http://www.w3.org/1999/xhtml">
  &lt;template>
   &lt;polygon attributes="transform" points="0 0, 1 0, 0 -1" xmlns="http://www.w3.org/2000/svg"/>
  &lt;/template>
 &lt;/binding>
&lt;/...></pre>

   <p>Assuming the above file was called <code>triangles.xml</code>, these
    bindings could be bound to elements using CSS like so:</p>

   <pre>@namespace triangles url(http://triangles.example.com/);
triangles|isosceles { binding: url(triangles.xml#isosceles); }
triangles|rightangle { binding: url(triangles.xml#rightangle); }</pre>

   <p>If the stylesheet was called <code>triangles.css</code>, an SVG file
    using these elements might look like:</p>

   <pre>&lt;?xml-stylesheet href="triangles.css"?>
&lt;svg xmlns="http://www.w3.org/2000/svg"
     xmlns:t="http://triangles.example.com/">
 &lt;circle cx="10" cy="10" r="5"/>
 &lt;rect x="20" y="20" height="5" width="10"/>
 &lt;t:isosceles transform="translate(10 20) scale(10)"/>
 &lt;t:rightangle transform="translate(20 20) scale(10)"/>
&lt;/svg></pre>

   <p>The same example could also be done all in one file like this:</p>

   <pre>&lt;svg xmlns="http://www.w3.org/2000/svg"
     xmlns:t="http://triangles.example.com/">
 &lt;defs>
  &lt;binding id="isosceles" xmlns="http://www.w3.org/1999/xhtml">
   &lt;template>
    &lt;polygon attributes="transform" points="0 -1, 1 0, -1 0" xmlns="http://www.w3.org/2000/svg"/>
   &lt;/template>
  &lt;/binding xmlns="http://www.w3.org/1999/xhtml">
  &lt;binding id="rightangle">
   &lt;template>
    &lt;polygon attributes="transform" points="0 0, 1 0, 0 -1" xmlns="http://www.w3.org/2000/svg"/>
   &lt;/template>
  &lt;/binding>
  &lt;style type="text/css">
   @namespace triangles url(http://triangles.example.com/);
   triangles|isosceles { binding: url(#isosceles); }
   triangles|rightangle { binding: url(#rightangle); }
  &lt;/style>
 &lt;/defs>
 &lt;circle cx="10" cy="10" r="5"/>
 &lt;rect x="20" y="20" height="5" width="10"/>
 &lt;t:isosceles transform="translate(10 20) scale(10)"/>
 &lt;t:rightangle transform="translate(20 20) scale(10)"/>
&lt;/svg></pre>
  </div>

  <h3 id=attachment-using-the-dom><span class=secno>3.4. </span>Attachment
   using the DOM</h3>

  <p>Bindings can be attached to elements through the DOM using the <a
   href="#dom-interfaces"><code>ElementXBL</code></a> interface. The method
   <a href="#addbinding"><code>addBinding</code></a> takes a binding URI and
   attaches the binding to the element.

  <pre class="dom
   example">var checkbox = document.getElementById("mycheckbox");
checkbox.addBinding("http://www.example.org/res/htmlBindings.xbl#checkbox");</pre>

  <p>This attachment is not necessarily synchronous. Scripts that invoke this
   method should not assume that the binding is installed immediately after
   this method returns. (An <a href="#xbl-bound"><code>xbl-bound</code></a>
   event is fired when the binding is installed.)

  <p>When a binding is attached using the DOM, it inherits from the current
   <a href="#most-derived-binding">most derived binding</a> that is already
   attached to the element, if any. (See: <a
   href="#binding-inheritance0">binding inheritance</a>.)

  <p>Any bindings attached to an element using the <a
   href="#addbinding"><code>addBinding()</code></a> method will remain on the
   element until the element is destroyed or a corresponding <a
   href="#removebinding"><code>removeBinding()</code></a> call is made.

  <p class=note>Attaching a binding using the <a
   href="#addbinding"><code>addBinding()</code></a> DOM APIs does not <a
   href="#importing-binding-documents0">import</a> the binding document. The
   <a href="#element"><code title=attr-binding-element>element</code></a>
   attributes of <a href="#binding0"><code>binding</code></a> elements in the
   binding document do not take effect unless the binding document is
   imported. (See: <a href="#importing-binding-documents0"
   title=import>importing binding documents</a>.)

  <p>Attaching using the <a href="#addbinding"><code>addBinding()</code></a>
   API does not affect the <a
   href="#bindings-are-ready">bindings-are-ready</a> counter.

  <h3 id=binding-attachment-model><span class=secno>3.5. </span><dfn
   id=binding-attachment-model0>Binding Attachment Model</dfn></h3>

  <p>When a new binding is attached, the UA must perform the following steps
   in order (or act as if it did). Implementations may choose to suspend
   redraw during this process.

  <ol>
   <li>If the binding has an <a href="#extends"><code
    title=attr-binding-extends>extends</code></a> attribute, then the user
    agent must immediately consider the binding that the attributes
    references (if any) to apply to the bound element as well, and must
    attach that binding first, recursively applying these steps to that
    binding. If this causes a loop &mdash; that is, if a binding directly or
    indirectly derives from itself through a chain of one or more <a
    href="#extends"><code title=attr-binding-extends>extends</code></a>
    attributes &mdash; then the user agent must only apply each binding in
    the chain once. (See: <a href="#explicit-inheritance0">explicit
    inheritance</a>, <a
    href="#interpretation-of-uris-to-xbl-bindings0">interpretation of URIs to
    XBL bindings</a>.)

   <li>If the binding has a template, the binding's shadow tree must be
    generated. This may cause other bindings to be applied synchronously, if
    their binding documents are already loaded. (See: <a
    href="#rules-for-shadow-content-generation0">rules for shadow content
    generation</a>, <a href="#binding-attachment-and-detachment0">binding
    attachment and detachment</a>.)

   <li>If other bindings are already attached to the bound element, then the
    newly added binding will add a new <a
    href="#explicit-inheritance-chain">explicit inheritance chain</a> to the
    element's list of bindings (its <a
    href="#implicit-inheritance-chain">implicit inheritance chain</a>). (See:
    <a href="#implicit-inheritance0">implicit inheritance</a>.)

   <li>If the new binding has an implementation, it must be made available to
    scripts. Language-specific constructors for the binding implementation
    must run at this point. (See: <a href="#binding-implementations0">binding
    implementations</a>.)

   <li>Events must start being routed through the binding's <a
    href="#internal-object">internal object</a>, when there is one. (See: <a
    href="#event-forwarding0">event forwarding</a>.)

   <li>If the new binding changes which shadow trees contribute to the <a
    href="#final-flattened-tree">final flattened tree</a> then the <a
    href="#explicit-children">explicit children</a> must be redistributed.
    (See: <a href="#processing-content-elements0">processing <code
    title="">content</code> elements</a>.)
  </ol>

  <p>The attachment process for the binding must then wait for the above
   steps to have been completed for all bindings that are known to apply to
   elements. When all the new bindings have reached this point, then, for
   each newly attached binding, the <a
   href="#xblbindingattached"><code>xblBindingAttached()</code></a> method
   must be invoked on the binding's <a
   href="#implementation">implementation</a>, immediately followed, if that
   bound element <a href="#is-in-a-document">is in a document</a>, by the
   invocation of the <a
   href="#xblentereddocument"><code>xblEnteredDocument()</code></a> method.

  <p>The order that bindings on different bound elements have these methods
   called must be the relative tree order of all their bound elements, as
   returned by the <code>compareDocumentPosition()</code> function. In
   certain cases (e.g. bound elements in disconnected fragments), this order
   is implementation-specific; however, it must always be consistent with the
   return values of that function. <a href="#refsDOM3CORE">[DOM3CORE]</a>

  <p>The order that bindings on the same bound element have these methods
   called must be the derivation order, with less derived bindings being
   initialized before more derived bindings.

  <p>After all the appropriate methods have been called, an <dfn id=xbl-bound
   title=xbl-bound><code>xbl-bound</code></dfn> event that bubbles, is not
   cancelable, has no default action, and uses the <code>Event</code>
   interface, must be fired on every bound element that just got bound, in
   the same order as their <a
   href="#xblbindingattached"><code>xblBindingAttached()</code></a> methods
   were invoked. (See: <a href="#binding-inheritance0">binding
   inheritance</a>.) <a href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  <p>If a binding stops applying to a document while the above steps are
   being applied, the binding is not removed until after the steps above have
   all been completed. Once they have been completed, any bindings that no
   longer apply must be detached. (See: <a
   href="#binding-detachment-model0">binding detachment model</a>.)

  <h3 id=handling-insertion-and-removal-from-the-><span class=secno>3.6.
   </span><dfn id=handling-insertion-and-removal-from-the-0>Handling
   Insertion and Removal from the Document</dfn></h3>

  <p>A bound element <dfn id=is-in-a-document>is in a document</dfn> if it
   has a <code>Document</code> node as an ancestor, or it is in a shadow tree
   and that shadow tree's bound element is itself <a href="#is-in-a-document"
   title="is in a document">in a document</a>.

  <p>When a bound element that is not <a href="#is-in-a-document" title="is
   in a document">in a document</a> is affected in such a way that it
   subsequently <a href="#is-in-a-document"><em>is</em> in a document</a>,
   then the <a
   href="#xblentereddocument"><code>xblEnteredDocument()</code></a> method
   must be invoked on the binding's <a
   href="#implementation">implementation</a>.

  <p>Similarly in reverse: when a bound element that <a
   href="#is-in-a-document"><em>is</em> in a document</a> is affected in such
   a way that it subsequently is <em>not</em> <a href="#is-in-a-document"
   title="is in a document">in a document</a>, then the <a
   href="#xblleftdocument"><code>xblLeftDocument()</code></a> method must be
   invoked on the binding's <a href="#implementation">implementation</a>.

  <p>These methods must be invoked as soon as the DOM is in a stable state,
   after any mutation events have fired, and after all running scripts have
   finished executing. If a bound element is removed and then reinserted into
   a document (or vice versa) during script execution, or while mutation
   events are being fired, the user agent must coalesce all the notifications
   into zero or one method calls (i.e. matching pairs of insertions and
   removals must not cause bindings to be notified).</p>
  --><!-- XXX this needs work --><!--

  <h3 id=binding-inheritance><span class=secno>3.7. </span><dfn
   id=binding-inheritance0>Binding Inheritance</dfn></h3>

  <p>Bindings can inherit from each other explicitly using the <a
   href="#extends"><code title=attr-binding-extends>extends</code></a>
   attribute. They can also inherit from each other <em>implicitly</em> if
   multiple bindings are attached to an element.

  <div class="figure example">
   --><!-- Note: alt="" is correct for the following image, since the
        caption says everything the image says. --><!--
   
   <p><img alt="" src="images/attachment.gif"></p>

   <div class=caption>
    <p>The implicit inheritance link can be pictured as having several
     explicit chains adjacent to each other, with the implicit inheritance
     chain going down each explicit inheritance chain sequentially.</p>

    <p>Consider a case where seven bindings are defined, "a", which inherits
     from "b" which inherits from "c"; "d", which stands alone; and "e",
     which inherits from "f" which inherits from "g". If a bound element E is
     bound to "a", "b", "d", and "e" (with "e" bound last), then there would
     be nine bindings attached to E. Four of them would be explicitly bound,
     and five would be part of explicit inheritance chains from those four.</p>

    <p>In such an example, you would also get implicit inheritance from "g"
     to "d", from "d" to "b", and from one of the instances of "c" to "a".</p>
   </div>
  </div>

  <p>An <dfn id=explicit-inheritance-chain>explicit inheritance chain</dfn>
   is a chain of bindings connected using the <a href="#extends"><code
   title=attr-binding-extends>extends</code></a> attribute.

  <p>An <dfn id=implicit-inheritance-chain>implicit inheritance chain</dfn>
   is a chain of <a href="#explicit-inheritance-chain" title="explicit
   inheritance chain">explicit inheritance chains</a>. There can be at most
   one <em>implicit</em> inheritance chain per bound element.

  <p>A <dfn id=base-binding>base binding</dfn> is a binding that does not
   inherit from any other binding, either explicitly or implicitly. The base
   binding of a bound element is at one end of the bound element's implicit
   inheritance chain.

  <p>A <dfn id=base-binding-of-the-explicit-chain>base binding of the
   explicit chain</dfn> is any binding that does not inherit explicitly from
   another, but may inherit implicitly from other bindings.

  <p>A <dfn id=most-derived-binding>most derived binding</dfn> is a binding
   that no other binding inherits from. The most derived binding of a bound
   element is the binding at the other end of the bound element's implicit
   inheritance chain from the base binding.

  <p>If <var title="">B<sub title=""><var title="">i</var></sub></var> is the
   <var title="">i</var>th binding in a group of <var title="">N</var>
   chains, where <var title="">B<sub title="">1</sub></var> is the <a
   href="#base-binding">base binding</a> and <var title="">B<sub
   title=""><var title="">N</var></sub></var> is the <a
   href="#most-derived-binding">most derived binding</a>, then <var
   title="">B<sub title=""><var title="">i</var>-1</sub></var> is the <dfn
   id=next-most-derived>next most derived</dfn> binding of <var
   title="">B<sub title=""><var title="">i</var></sub></var>.

  <p>In this specification, inheritance is represented as an arrow pointing
   to the binding that is being inherited. Thus, in the chain A&rarr;B, the A
   binding is the most derived binding, and the B binding is the next most
   derived binding, in this case also the base binding.

  <p class=example>In the example above, the <a href="#base-binding"><em>base
   binding</em></a> is the first "c", the four <a
   href="#base-binding-of-the-explicit-chain"><em title="base binding of the
   explicit chain">base bindings of the explicit chains</em></a> are "c",
   "c", "d", and "g", and the <a href="#most-derived-binding"><em>most
   derived binding</em></a> is "e".

  <p class=note>The results of inheritance are described in the sections on
   <a href="#binding-implementations0">binding implementations</a> and <a
   href="#shadow-content0">shadow content</a>.

  <h4 id=explicit-inheritance><span class=secno>3.7.1. </span><dfn
   id=explicit-inheritance0>Explicit Inheritance</dfn></h4>

  <p>The <a href="#binding0"><code>binding</code></a> element's <a
   href="#extends"><code title=attr-binding-extends>extends</code></a>
   attribute gives an explicit inheritance chain for a binding, ensuring that
   whenever the binding is bound to an element, the named binding also gets
   bound. (See: <a href="#binding-attachment-model0">binding attachment
   model</a>, <a href="#binding-detachment-model0">binding detachment
   model</a>.)

  <p>The <a href="#extends"><code
   title=attr-binding-extends>extends</code></a> attribute thus creates an <a
   href="#explicit-inheritance-chain">explicit inheritance chain</a>.

  <p>If a <a href="#binding0"><code>binding</code></a> element's <a
   href="#extends"><code title=attr-binding-extends>extends</code></a>
   attribute is changed, then, for each time the binding is bound to an
   element, the user agent must follow these steps:

  <ol>
   <li>
    <p>Let <var title="">binding</var> be the instance of the binding that is
     attached to the bound element.</p>

   <li>
    <p>If <var title="">binding</var> is not <em>directly</em> attached to
     the bound element, but is instead attached to the bound element because
     another binding is inheriting from it using the <a href="#extends"><code
     title=attr-binding-extends>extends</code></a> attribute, then let <var
     title="">binding</var> be <em>that</em> binding instead, and repeat this
     step.</p>

    <p>Otherwise, <var title="">binding</var> was attached to the bound
     element directly, and is not being inherited by another binding using
     the <a href="#extends"><code
     title=attr-binding-extends>extends</code></a> attribute.</p>

   <li>
    <p>Detach <var title="">binding</var>. (See: <a
     href="#binding-detachment-model0">binding detachment model</a>.)</p>

   <li>
    <p>Attach a new instance of <var title="">binding</var> so that it is in
     the same place in the binding chain as the old instance was. (See: <a
     href="#binding-attachment-model0">binding attachment model</a>, <a
     href="#implicit-inheritance0">implicit inheritance</a>.)</p>
  </ol>

  <p class=note>It is possible to form a loop with the <a
   href="#extends"><code title=attr-binding-extends>extends</code></a>
   attribute. For example, a binding A can inherit from B which inherits from
   C which inherits from B again. The attachment algorithm is defined in a
   way that makes the loop stop as soon as a duplicate binding would be
   bound. In this case, the user agent will form a chain starting with A (the
   <a href="#most-derived-binding">most derived binding</a>), derived from B,
   derived from C, with C as the <a href="#base-binding">base binding</a>
   (chain A&rarr;B&rarr;C). If, given the same definitions, the element was
   bound directly to C, then the chain would be C&rarr;B.

  <h4 id=implicit-inheritance><span class=secno>3.7.2. </span><dfn
   id=implicit-inheritance0>Implicit Inheritance</dfn></h4>

  <p>When two bindings are both attached to the same element, the <a
   href="#base-binding-of-the-explicit-chain" title="base binding of the
   explicit chain">base binding</a> at the end of the <a
   href="#explicit-inheritance-chain">explicit inheritance chain</a> of the
   second binding implicitly inherits from the <a
   href="#most-derived-binding">most derived binding</a> of the explicit
   inheritance chain of the first.

  <p>If one of the <a href="#explicit-inheritance-chain" title="explicit
   inheritance chain">explicit inheritance chains</a> is removed, then the
   remaining binding chains are reconnected so that the <a
   href="#base-binding-of-the-explicit-chain">base binding of the explicit
   chain</a> after the break now inherits from the <a
   href="#most-derived-binding">most derived binding</a> before the break.

  <p>The order of bindings is always such that bindings added via the <a
   href="#binding0"><code>binding</code></a> element are first (in the order
   the bindings are specified in the file, with the files, if there are more
   than one, ordered in the same order that they are referred to, traversed
   pre-order, depth-first), the bindings attached via CSS are second (in the
   order specified on the '<a href="#binding1"><code title="binding
   property">binding</code></a>' property), and the bindings added via <a
   href="#addbinding"><code>addBinding</code></a> are third (in the order
   they were attached, most recently attached being the <a
   href="#most-derived-binding">most derived binding</a>).

  <div class=example>
   <p>For example, take a binding <em>d<sub>1</sub></em>, which specifies a
    base binding <em>d<sub>2</sub></em> using the <a href="#extends"><code
    title=attr-binding-extends>extends</code></a> attribute such that its
    explicit inheritance chain is:</p>

   <p><em>d<sub>1</sub></em> &rarr; <em>d<sub>2</sub></em></p>

   <p>If binding <em>d<sub>1</sub></em> is attached to an element using <a
    href="#addbinding"><code>addBinding</code></a> that already has a binding
    chain of:</p>

   <p><em>s<sub>1</sub></em> &rarr; <em>s<sub>2</sub></em> &rarr;
    <em>s<sub>3</sub></em></p>

   <p>...then the base binding at the end of the inheritance chain,
    <em>d<sub>2</sub></em>, is the one that will inherit from the most
    derived binding that is already attached to the element,
    <em>s<sub>1</sub></em>. The resulting binding chain following the
    addition of the binding is therefore:</p>

   <p><em>d<sub>1</sub></em> &rarr; <em>d<sub>2</sub></em> &rarr;
    <em>s<sub>1</sub></em> &rarr; <em>s<sub>2</sub></em> &rarr;
    <em>s<sub>3</sub></em></p>

   <p>The inheritance between <em>d<sub>2</sub></em> and
    <em>s<sub>1</sub></em> is <em>implicit</em>, meaning that there is no
    connection in the markup for the bindings between the two bindings. The
    inheritance link has been forged dynamically through the invocation of
    the <a href="#addbinding"><code>addBinding</code></a> method.</p>
  </div>

  <p>An element can be bound to the same binding multiple times, in which
   case a binding can end up inheriting from itself. (This can only happen
   via implicit inheritance, though.)

  <h4 id=mixing-implicit-and-explicit-inheritance><span class=secno>3.7.3.
   </span>Mixing Implicit and Explicit Inheritance</h4>

  <div class=example id=mixed-inheritance-example>
   <p>Consider the following completely useless but short bindings in in XML
    file (called, for the sake of argument, "<code>test.xml</code>"):</p>

   <pre>&lt;html xmlns="http://www.w3.org/1999/xhtml">
 &lt;binding id="a">
  &lt;template> l &lt;inherited> l &lt;content> o &lt;/content> - &lt;/inherited> W &lt;/template>
 &lt;/binding> 
 &lt;binding id="b" element="[X]" extends="#a">
  &lt;template> e &lt;inherited> error &lt;/inherited> o &lt;content> r &lt;/content> &lt;/template>
 &lt;/binding>
 &lt;binding id="c" element="[Y]">
  &lt;template> H &lt;inherited> error &lt;/inherited> l &lt;content> error &lt;/content> ! &lt;/template>
 &lt;/binding>
&lt;/html></pre>

   <p>When imported by the following equally silly but simple document:</p>

   <pre>&lt;?xbl href="test.xml"?>
&lt;root X="" Y=""> d &lt;/root></pre>

   <p>The resulting flattened tree would spell
    "H&nbsp;e&nbsp;l&nbsp;l&nbsp;o&nbsp;-&nbsp;W&nbsp;o&nbsp;r&nbsp;l&nbsp;d&nbsp;!".</p>

   <p>

   <p>The binding "c" that attaches because of the Y attribute implicitly
    inherits from the binding "b" that is bound because of the X attribute,
    and that latter binding explicitly inherits from the "a" binding. Since
    the "Y" binding has a <a href="#content"><code>content</code></a>
    element, the "d" explicit child node of the bound element ends up
    assigned to the <a href="#content"><code>content</code></a> element in
    the "Y" binding.</p>

   <p>The following table shows the source of each character:</p>

   <table>
    <tbody>
     <tr>
      <th> Output:

      <td> H

      <td> e

      <td> l

      <td> l

      <td> o

      <td> -

      <td> W

      <td> o

      <td> r

      <td> l

      <td> d

      <td> !

     <tr>
      <th> Source:

      <td> c

      <td> b

      <td> a

      <td> a

      <td> a

      <td> a

      <td> a

      <td> b

      <td> b

      <td> c

      <td> R

      <td> c
   </table>

   <p>...where R represents the bound document.</p>

   <p>The inheritance chain of the bindings attached to the <code
    title="">root</code> element in this example is:</p>

   <pre>c &rarr; b &rarr; a</pre>

   <p>...where the first arrow is an implicit inheritance, and the second is
    an explicit inheritance.</p>
  </div>

  <h3 id=attachment-during-document-load><span class=secno>3.8.
   </span>Attachment During Document Load</h3>

  <p>Binding loads are asynchronous. That is to say, when a binding is added
   (either via style sheet, script, or some other method), and the relevant
   <a href="#binding-document">binding document</a> is not yet loaded, the
   load must be started in the background and the binding only attached once
   the binding document is available. An author can ensure that all bindings
   are synchronously attached by calling <a
   href="#loadbindingdocument"><code>loadBindingDocument</code></a> to
   pre-fetch any binding documents that are required.

  <p>The bound document must wait until all XBL dependencies have loaded
   before firing its <code title=event-load>load</code> event.

  <h3 id=binding-detachment-model><span class=secno>3.9. </span><dfn
   id=binding-detachment-model0>Binding Detachment Model</dfn></h3>

  <p>When a binding is detached, the <a
   href="#xblleftdocument"><code>xblLeftDocument()</code></a> method must be
   invoked on the binding's <a href="#implementation">implementation</a>.
   Then, the shadow tree must be removed, the implementation must be removed
   from the bound element's list of binding implementations, and any
   forwarding of events to the binding must be stopped for this bound
   element.

  <p>If the binding had an <a href="#extends"><code
   title=attr-binding-extends>extends</code></a> attribute when it was bound
   to the element (it may have changed since then, in which case the binding
   is being detached precisely for that reason), then the user agent must
   then detach the binding that was attached because of that attribute (if
   any). (See: <a href="#explicit-inheritance0">explicit inheritance</a>, <a
   href="#interpretation-of-uris-to-xbl-bindings0">interpretation of URIs to
   XBL bindings</a>.)

  <p>If the binding had a shadow tree, the explicit children must then be
   redistributed. (See: <a href="#processing-content-elements0">processing
   <code title="">content</code> elements</a>.)</p>
  --><!-- XXX need to define how this works when multiple bindings stop
  applying at once, and if they re-apply while being removed -->

  <h2 id=shadow-content><span class=secno>4. </span><dfn
   id=shadow-content0>Shadow Content</dfn></h2>

  <p>The subtree that is rendered in the document, but is not accessible from
   the document via standard Core DOM navigation facilities such as
   <code>firstChild</code> or <code>nextSibling</code> is called
   <dfn id=shadow-tree>shadow tree</dfn>.

  <p>An element declared in a document using a single element can then be
   constructed out of multiple elements in its shadow subtre, and this
   implementation is hidden from the document.

  <p>An element can only have one shadow tree. If an element has a
   shadow tree, it is called a <dfn id=shadow-host>shadow host</dfn>.

  <p>Any explicit children of the shadow host element are combined by the user
   agent into a <dfn id=flattened-tree>flattened tree</dfn> for the purposes of
   rendering and hit-testing.

  <p>A shadow tree can be specified in two ways:

    <ol>
      <li>with a <a href="#shadow-content-template"
       title="shadow content template">shadow content template</a>.
      <li>by building the tree with Core DOM methods during the
       <a href="#binding-phase">binding phase</a>.
    </ol>

  <p>The term <dfn id=shadow-content1 title="">shadow content</dfn> refers to
   the various nodes in the shadow tree of a host element.

   <p>The subtree specified by the <a
    href="#template"><code>template</code></a> element is referred to as the
    <dfn id=shadow-content-template>shadow content template</dfn>. This
    template describes a subtree that will be generated under the host
    element during the <a href="#binding-phase">binding phase</a>.

  <div class=example>
   <p>For example, the HTML file upload control appears in most browsers as a
    composite widget consisting of a text field and a button. A sample
    template for the file widget might look as follows:</p>

   <pre>&lt;template&gt;
  &lt;input type="text"/&gt;
  &lt;input type="button"/&gt;
&lt;/template&gt;</pre>

   <p>Because this content is not visible to its parent element, it is said
    to be <a href="#shadow-content0"><em>shadow content</em></a>.</p>
  </div>

  <p class=note>The file control is actually a special case. Due to security
   considerations, untrusted bindings will typically not be able to extend
   the file upload control in UAs intended for use with untrusted content.

  <h3 id=rules-for-shadow-content-generation><span class=secno>4.1.
   </span><dfn id=rules-for-shadow-content-generation0>Rules for Shadow
   Content Generation</dfn></h3>

  <p>When a shadow tree is generated, user agents must act as follows:

  <p>If the binding element has no <a
   href="#template"><code>template</code></a> element, then no shadow content
   will be generated for this binding.

  <p>Otherwise, its first <a href="#template"><code>template</code></a>
   element must be deeply cloned.

  <p>The <code>xml:base</code> data of the cloned <a
   href="#template"><code>template</code></a> element must be set so that the
   <code>baseURI</code> of nodes in the resulting shadow tree is the same as
   their pre-cloning counterparts. All shadow nodes'
   <code>ownerDocument</code> pointers are left pointing at their binding
   documents' <code>Document</code> node(s).

  <p>No mutation events must be fired during the above steps.

  <p>Any bindings that apply to elements in the shadow tree must be applied.

  <p>For bindings with implementations: the <a
   href="#shadowtree"><code>shadowTree</code></a> member of the <a
   href="#internal-object">internal object</a> must be set to be a reference
   to the <a href="#template"><code>template</code></a> element clone (the
   root of the shadow tree).

  <p>The shadow tree is then <dfn id=applied>applied</dfn> to the bound
   element: the binding's shadow tree is placed in the appropriate place in
   the final flattened tree, <a href="#explicit-children">explicit
   children</a> are (re)distributed to the appropriate <a
   href="#content"><code>content</code></a> elements, and the CSS cascade and
   inheritance is be computed along the new tree. (See: <a
   href="#processing-content-elements0">processing <code
   title="">content</code> elements</a>.)

  <p>After this point, further bindings may need to be applied, or certain
   bindings may need to be removed (because of CSS inheritance or because the
   selectors that decide which elements match which bindings can be affected
   by the shadow tree being associated with the bound element).

  <p>Everything described in this section must be completed atomically
   &mdash; that is, the UA must not execute author scripts during this
   process.

  <p class=note>Some implementations might optimize this algorithm, such as
   using "lazy evaluation" approaches and thereby postpone the cascade and
   inheritance operations.

  <h3 id=rules-for-shadow-content-destruction><span class=secno>4.2.
   </span><dfn id=rules-for-shadow-content-destruction0>Rules for Shadow
   Content Destruction</dfn></h3>

  <p>The destruction of a shadow tree consists of recreating the <a
   href="#final-flattened-tree">final flattened tree</a> without the
   influence of that binding's shadow tree by redistributing the <a
   href="#explicit-children">explicit children</a> to the remaining shadow
   trees' <a href="#content"><code>content</code></a> elements (or, if there
   are none, putting the nodes back directly under the bound element).

  <p>The <a href="#shadowtree"><code>shadowTree</code></a> member of the <a
   href="#internal-object">internal object</a> must be set to null.

  <h3 id=attribute-forwarding><span class=secno>4.3. </span><dfn
   id=attribute-forwarding0>Attribute Forwarding</dfn></h3>

  <p>Attributes on shadow content elements can be tied to attributes on the
   bound element; then, whenever the attribute is set or removed on the bound
   element, the corresponding attribute on the shadow content is also set or
   removed. On any shadow content element, an <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attribute can be used to
   specify a <a
   href="#attributes-containing-space-separated-va0">space-separated</a> list
   of attributes that should be inherited. Attributes with namespaces can be
   defined using a namespace prefix and the attribute name separate by a
   colon.

  <div class=example>
   <p>For example, returning to the HTML file upload control example above,
    the shadow text field can be set up to automatically inherit the
    <code>value</code> attribute from the bound element.</p>

   <pre>&lt;binding id="fileUploadControl"&gt;
  &lt;template&gt;
    &lt;input type="text" attributes="value"/&gt;
    &lt;input type="button" value="Browse..."/&gt;
  &lt;/template&gt;
&lt;/binding&gt;</pre>
  </div>

  <p>Each entry in the <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> list can either simply list an
   attribute name (a string, such as <code>value</code> in the example above,
   containing no spaces, colons, asterisks, or hash marks<!-- Unicodify -->),
   or it can specify an <code>=</code>-separated pair of attribute names
   (ditto), consisting of the attribute on the shadow content that should be
   tied to the attribute on the bound element. When two names are specified,
   the attribute to be added on the shadow content node is listed first, and
   the attribute of the bound element is second.

  <p>Each entry may also be suffixed by a single hash mark (#) followed by a
   <a href="#type-designation">type designation</a>.

  <p>The <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attribute's value must be
   parsed as follows. First, it must be split on spaces (treated as a <a
   href="#attributes-containing-space-separated-va0">space-separated</a>
   value). Next, each resulting item must be matched against the <code
   title="">attributes-item</code> production in the following ABNF:

  <pre>
attributes-item     := attribute [ '=' attribute ] [ '#' type ]
attribute           := *attribute-character / special-attribute
attribute-character := &lt; any character but ':', '=', '#', or '*' >
special-attribute   := '*text' / '*lang'
type                := '#' ( 'url' / 'text' )</pre>
  <!-- XXX this is Unicode ABNF bla bla -->

  <p>If any item does not match this pattern, then the item is <a
   href="#in-error">in error</a> and must be ignored. Other items in the
   list, if any, are not affected by this.

  <p>The values <a href="#pseudo"><code title=attr-pseudo>pseudo</code></a>
   and <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a>, if used such that they match
   the <code title="">attribute</code> production of the above ABNF, are <a
   href="#in-error">in error</a> and must be ignored.

  <h4 id=forwarding-to-and-from-text-nodes><span class=secno>4.3.1.
   </span>Forwarding to and from text nodes</h4>

  <p>The special value <dfn id=text><code>*text</code></dfn> can be used in
   an <code title="">=</code>-separated pair.

  <p>When specified on the left-hand side of the pair it indicates that the
   value of the attribute on the right-hand side are to be represented as
   text nodes underneath the shadow element in the <a
   href="#final-flattened-tree">final flattened tree</a>. If the element has
   any child nodes in the DOM (any nodes, including comment nodes, whitespace
   text nodes, or even empty CDATA nodes) then the pair is <a
   href="#in-error">in error</a> and UAs must ignore it, meaning the
   attribute value is not forwarded. Otherwise, a text node must be created,
   and that text node will be placed under the element in the final flattened
   tree.

  <p>Text nodes created in this way are orphans; their
   <code>parentNode</code>, <code>nextSibling</code>,
   <code>previousSibling</code>, <code>childNodes</code>,
   <code>firstChild</code>, and <code>lastChild</code> attributes are all
   null or empty. Their <code>ownerDocument</code> attribute is set to the
   same as the shadow content node that generated them. (The only way one of
   these text nodes can be accessed is if the element is itself bound: the
   text node might then appear in a <a
   href="#content"><code>content</code></a> element's <a
   href="#xblchildnodes"><code>xblChildNodes</code></a> list.)

  <p>When used on the right-hand side, it indicates that any text nodes
   (including CDATA nodes and whitespace text nodes) that are <a
   href="#explicit-children">explicit children</a> of the bound element must
   have their data concatenated and the resulting value stored as the
   attribute on the left-hand side.</p>
  <!--XXX use textContent instead? innerText?
  The HTML5 special version? -->

  <h4 id=forwarding-language-metadata><span class=secno>4.3.2.
   </span>Forwarding language metadata</h4>

  <p>The special value <dfn id=lang><code>*lang</code></dfn> can also be used
   in an <code title="">=</code>-separated pair.

  <p>When used on the right-hand side, it indicates that the value to be
   copied is the natural language of the bound element, typically given by
   the attribute <code title=attr-lang>lang</code> of that element or an
   ancestor, or by HTTP headers, or similar. If no language is defined, then
   the value to be copied must be the empty string.

  <p>The <a href="#lang"><code>*lang</code></a> value cannot occur by itself
   or on the left-hand side. If it does, it is <a href="#in-error">in
   error</a> and UAs must <a href="#ignoring">ignore</a> that value in the
   element's <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attribute.

  <h4 id=error-handling0><span class=secno>4.3.3. </span>Error handling</h4>

  <p>If an attribute is listed multiple times on the left hand side (or on
   its own), then the last designation wins (as if the attributes were each
   forwarded in turn, an earlier forwarding being overwritten by a later
   one), and all the ones before the first are <a href="#in-error">in
   error</a>.

  <h4 id=type-specifiers><span class=secno>4.3.4. </span>Type specifiers</h4>

  <p>If the attribute or attribute pair is followed by a <dfn
   id=type-designation>type designation</dfn>, in the form of a hash mark
   character ("#") and by a type name, then the value must be processed as
   described for its type below before being forwarded.

  <dl>
   <dt>If the type is <dfn id=url title=type-url><code>url</code></dfn>

   <dd>The value must be resolved to an absolute URI using the base URI of
    the source element before being forwarded.

   <dt>If the type is <dfn id=text0 title=type-text><code>text</code></dfn>
    (default)

   <dd>The value is forwarded unchanged.

   <dt>If the type is any other value

   <dd>The attribute must not be forwarded. The value is <a
    href="#in-error">in error</a> and UAs must <a href="#ignoring">ignore</a>
    that value in the element's <a href="#attributes4"><code
    title=attr-attributes>attributes</code></a> attribute.
  </dl>

  <div class=example>
   <p>In the following shadow template, the "src" attribute on the bound
    element is forwarded to the "src" attribute on the <code>image</code>
    element in the shadow tree, and the link will work even if the original
    attribute had a relative URI and the base URIs of the various nodes are
    different:</p>

   <pre>
&lt;template&gt;
  &lt>img attributes="src#url title alt=*text lang=*lang"/&gt;
&lt;/template&gt;
    </pre>

   <p>This example also shows how to turn the value of an attribute on the
    bound element, in this case the "alt" attribute, into child nodes of the
    element in the shadow tree, using <a href="#text"><code>*text</code></a>.
    For accessibility reasons, the language of the element is also explicitly
    forwarded.</p>
  </div>
  <!-- XXX we need a way to translate x="foo" y="foo" to
  transform="translate(x,y)" and similar -->
  <!-- XXX we need a way to handle onfoo attributes on the bound
  element -->

  <h4 id=dynamic-changes><span class=secno>4.3.5. </span>Dynamic changes</h4>

  <p>The <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attribute must be parsed when
   the binding is first applied and whenever the attribute's value changes.
   It must be applied (causing the relevant attributes and text nodes to be
   updated) when the shadow tree is generated, when the attribute is changed,
   and whenever any of the bound element's attributes or text nodes referred
   to by the <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attribute change.

  <h4 id=how-attribute-forwarding-affects-the-sha><span class=secno>4.3.6.
   </span>How Attribute Forwarding Affects the Shadow Tree</h4>

  <p>The element to which the attributes are forwarded (that is, the element
   with the <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attribute specified) has its
   attributes mutated. Whenever attribute forwarding happens: existing
   attributes to which values are being forwarded must have their values
   changed, attributes that are being forwarded that do not yet exist on the
   shadow tree element must be added to the shadow tree element, attributes
   to which values would be forwarded but whose source attributes are not
   present on the bound element must be removed from the shadow tree element.

  <p>The shadow tree element's attributes can be changed dynamically, and
   this doesn't affect the attribute forwarding, until dynamic changes cause
   attribute forwarding to be performed again. When attribute forwarding is
   performed, all attributes are forwarded, even those that haven't changed
   on the bound element, thus blowing away any dynamic changes to the shadow
   tree element's attributes that are referenced by the <a
   href="#attributes4"><code title=attr-attributes>attributes</code></a>
   attribute.

  <h3 id=processing-content-elements><span class=secno>4.4. </span><dfn
   id=processing-content-elements0>Processing <code>content</code>
   Elements</dfn></h3>

  <p>A node is said to match a <a href="#content"><code>content</code></a>
   element when the <a href="#content"><code>content</code></a> element has
   no <a href="#includes"><code
   title=attr-content-includes>includes</code></a> attribute, or when the
   element in question matches the selector given by that <a
   href="#includes"><code title=attr-content-includes>includes</code></a>
   attribute.

  <p>If an element stops matching a <a
   href="#content"><code>content</code></a> element that it is assigned to,
   then the bound element's explicit chlidren must be redistributed.

  <h4 id=how-nodes-are-distributed><span class=secno>4.4.1. </span>How Nodes
   are Distributed</h4>

  <p><img alt="" class=extra src="images/xbl_image_1.gif">XBL bindings can
   interleave shadow content between bound elements and their <a
   href="#explicit-children">explicit children</a>. They do so using XBL's <a
   href="#content"><code>content</code></a> element. Any number of <a
   href="#content"><code>content</code></a> nodes may be used in a binding's
   shadow content template.

  <p>In addition, the shadow trees of inherited bindings get inserted into
   the first <a href="#inherited"><code>inherited</code></a> element in the
   binding.

  <p>The <dfn id=explicit-children>explicit children</dfn> of an element are
   the nodes that are listed in the element's <code>childNodes</code> array,
   with the exception that any <a href="#content"><code>content</code></a>
   elements in that array are instead replaced by whatever nodes they
   currently have assigned to them, or, if no nodes are assigned to that <a
   href="#content"><code>content</code></a> element, by the child nodes of
   that <a href="#content"><code>content</code></a> element. If an element's
   <code>childNodes</code> list is empty but the element has an <a
   href="#attributes4"><code title=attr-attributes>attributes</code></a>
   attribute that uses the <a href="#text"><code>*text</code></a> value on
   the left hand side in a way that is not <a href="#in-error">in error</a>
   then its "explicit children" is the text node generated during <a
   href="#attribute-forwarding0">attribute forwarding</a>.

  <div class=example>
   <p>Consider the following simple document:</p>

   <pre>&lt;X xmlns="http://example.com/"&gt;&lt;A/&gt;&lt;/X&gt;</pre>

   <p>Now, if the element X in that document is bound to a binding with the
    following shadow tree template:</p>

   <pre>&lt;template xmlns:T="http://example.com/"&gt;
 &lt;my:T&gt;
  &lt;my:P/&gt;
  &lt;content/&gt;
  &lt;my:Q/&gt;
 &lt;/my:T&gt;
&lt;/template&gt;</pre>

   <p>The explicit children of the <code>T</code> element, ignoring
    whitespace nodes, are, in order, <code>P</code>, <code>A</code>, and
    <code>Q</code>. This is because the children of <code>T</code> are
    <code>P</code>, a <a href="#content"><code>content</code></a> element,
    and <code>Q</code>, and the <a href="#content"><code>content</code></a>
    element has just one node associated with it, namely the <code>A</code>
    element.</p>
  </div>

  <p>When the <a href="#explicit-children">explicit children</a> are
   distributed and assigned to the <a
   href="#content"><code>content</code></a> elements in the bound element's
   shadow trees, the <a href="#includes"><code
   title=attr-content-includes>includes</code></a> attribute determines which
   <a href="#content"><code>content</code></a> element a given child is to be
   placed under.

  <p>If no <a href="#includes"><code
   title=attr-content-includes>includes</code></a> attribute is specified, a
   <a href="#content"><code>content</code></a> element is considered generic
   and will match on all content, including text nodes, CDATA nodes,
   comments, and so on.

  <p>If the <a href="#includes"><code
   title=attr-content-includes>includes</code></a> attribute is specified, it
   must be interpreted as a <a
   href="#attributes-containing-selectors0">selector</a>, and only elements
   that <a href="#selectors-and-shadow-scopes0" title="selectors and shadow
   scopes">match the selector</a> apply to that <a
   href="#content"><code>content</code></a> element. If the selector is
   invalid, the <a href="#content"><code>content</code></a> element is <a
   href="#in-error">in error</a> and does not match any nodes. Matching of
   the elements to the selector is done without taking into account the
   shadow tree in which the <a href="#content"><code>content</code></a>
   element itself is found. <a href="#refsSELECTORS">[SELECTORS]</a>

  <p>Each node that is to be distributed (each <a href="#explicit-children"
   title="explicit children">explicit child node</a>) must be assigned to a
   <a href="#content"><code>content</code></a> element as follows:

  <ol>
   <li>If the node is already assigned to a <a
    href="#content"><code>content</code></a> element for this binding, and
    the <a href="#content"><code>content</code></a> element is <a
    href="#locked" title=attr-content-locked>locked</a>, then that is the <a
    href="#content"><code>content</code></a> element to which the node must
    be assigned, stop here.

   <li>Otherwise: if the node is already assigned to a <a
    href="#content"><code>content</code></a> element for this binding,
    unassign it.

   <li>Let <var>T</var> be the shadow tree of the <span>most derived</span>
    binding with a shadow tree for the bound element.

   <li>If <var>T</var> contains a <a href="#correct">correct</a> <a
    href="#content"><code>content</code></a> element that is not <a
    href="#locked" title=attr-content-locked>locked</a> and to which the node
    in question applies, then the first such element in a depth-first,
    pre-order traversal of the shadow tree <var>T</var> is the <a
    href="#content"><code>content</code></a> element to which the node must
    be assigned, stop here.

   <li>Otherwise, if this binding has no <a href="#correct">correct</a> <a
    href="#inherited"><code>inherited</code></a> element in its shadow tree,
    then the node is not assigned to a <a
    href="#content"><code>content</code></a> element, and does not appear in
    the <a href="#final-flattened-tree">final flattened tree</a>; stop here.

   <li>Otherwise, if the binding has a <a href="#correct">correct</a> <a
    href="#inherited"><code>inherited</code></a> element in its shadow tree
    but it is the least derived binding with a shadow tree, then the node is
    not assigned to a <a href="#content"><code>content</code></a> element,
    and does not appear in the <a href="#final-flattened-tree">final
    flattened tree</a>; stop here.

   <li>Otherwise, let <var>T</var> be the shadow tree of the <a
    href="#next-most-derived">next most derived</a> binding with a shadow
    tree and return to step 4.
  </ol>

  <p>The <a href="#explicit-children">explicit children</a> must be processed
   in order, so if two nodes are assigned to a <a
   href="#content"><code>content</code></a> element, their order in the <a
   href="#xblchildnodes"><code>xblChildNodes</code></a> list is the same as
   their relative order in the <a href="#explicit-children">explicit
   children</a> list.

  <div class=example>
   <p>Consider the following simple document:</p>

   <pre>&lt;X xmlns="http://example.com/"&gt;&lt;A/&gt;&lt;B/&gt;&lt;C/&gt;&lt;/X&gt;</pre>

   <p>Imagine that the element X in that document is bound to a binding with
    the following shadow tree template:</p>

   <pre>&lt;template xmlns:my="http://example.com/"&gt;
 &lt;my:T&gt;
  &lt;my:M/&gt;
  &lt;content/&gt;
  &lt;my:N/&gt;
 &lt;/my:T&gt;
&lt;/template&gt;</pre>

   <p>Imagine further that the element T is itself bound to a binding with
    the following template:</p>

   <pre>&lt;template xmlns:my="http://example.com/"&gt;
 &lt;my:R&gt;
  &lt;content includes="N"/&gt;
  &lt;content includes="B"/&gt;
 &lt;/my:R&gt;
&lt;/template&gt;</pre>

   <p>The resulting <a href="#final-flattened-tree">final flattened tree</a>
    would be:</p>

   <pre> X
 |
 `-- T
     |
     `-- R
         |
         +-- N
         |
         `-- B</pre>

   <p>In this example, there are two selectors, "N" and "B", both of which
    match just elements with the given local name.</p>
  </div>

  <h4 id=when-nodes-are-redistributed><span class=secno>4.4.2. </span>When
   Nodes Are Redistributed</h4>

  <p>The algorithm described in the previous section is applied when:

  <ul>
   <li><a href="#rules-for-shadow-content-generation0" title="Rules for
    Shadow Content Generation">A shadow tree is generated</a>.

   <li><a href="#rules-for-shadow-content-destruction0" title="Rules for
    Shadow Content Destruction">A shadow tree is destroyed and the bound
    element still has bindings with shadow trees</a>.

   <li><a href="#handling-dom-changes0" title="Handling DOM Changes">The
    bound element has explicit children added, removed, or moved</a>.

   <li><a href="#handling-dom-changes0" title="Handling DOM Changes">A shadow
    tree is modified in a way that affects the relative order of
    <code>content</code> elements or their <code
    title=attr-content-includes>includes</code> attributes</a>.

   <li><a href="#handling-dom-changes0" title="Handling DOM Changes">An <code
    title=attr-content-includes>includes</code> attribute in the shadow tree
    is mutated</a>.

   <li><a href="#processing-content-elements0" title="Processing content
    Elements">One or more of the nodes assigned to a <code>content</code>
    element in a shadow tree no longer match the element's <code
    title=attr-content-includes>includes</code> attribute.</a></li>
   <!-- XXXX the shadow tree is regenerated, e.g. template descendants
   are modified -->
  </ul>

  <div class=example>
   <p>Consider the following binding shadow tree:</p>

   <pre>&lt;template&gt;
 &lt;div&gt;As: &lt;content includes="A, AA"&gt;&lt;/content&gt;&lt;/div&gt;
 &lt;div&gt;Other: &lt;content&gt;&lt;/content&gt;&lt;/div&gt;
&lt;/template&gt;</pre>

   <p>If an element is bound to this binding while it has three child
    elements A, AA, and B, then the A and AA elements would end up under the
    first <a href="#content"><code>content</code></a> element, and the B
    element would end up under the second <a
    href="#content"><code>content</code></a> element. But if the <a
    href="#includes"><code title=attr-content-includes>includes</code></a>
    attribute of the first <a href="#content"><code>content</code></a>
    element in the shadow tree was then dynamically modified to just have the
    value "<code title="">A</code>", then the AA element would be reassigned
    to the second <a href="#content"><code>content</code></a> element.</p>
  </div>

  <h3 id=the-final-flattened-tree><span class=secno>4.5. </span>The <dfn
   id=final-flattened-tree>Final Flattened Tree</dfn></h3>

  <p>The final flattened tree is the view of the document and shadow trees
   after XBL has been fully applied. It is only used for two things:

  <dl>
   <dt>Rendering

   <dd>Rendering must be performed using the final flattened tree. Nodes that
    do not appear in the final flattened tree must not be rendered. (See: <a
    href="#css-property-inheritance-and-rendering0">CSS property inheritance
    and rendering</a>.)

   <dt>Event dispatch

   <dd>Events flow along the final flattened tree. (See: <a
    href="#event-flow-and-targeting-across-shadow-s0">event flow and
    targeting across shadow scopes</a>.)
  </dl>

  <p>All other processing continues to use the DOM Core tree. (See: <a
   href="#shadow-content-and-other-things0" title="Semantics of non-XBL
   elements in XBL contexts">shadow content and other things</a>.)

  <p>The final flattened tree must be constructed by taking the bound
   document's core DOM tree and performing the equivalent of the following
   steps on each bound element, until there are no more bound elements in the
   tree that have not been processed:

  <ol>
   <li>If the bound element has no shadow trees, move on to the next bound
    element.

   <li>Otherwise, replace the child nodes of the bound element with the child
    nodes of the most derived shadow tree's root <a
    href="#template"><code>template</code></a> element.

   <li>For any element in the shadow tree that has an <a
    href="#attributes4"><code title=attr-attributes>attributes</code></a>
    attribute that uses the <a href="#text"><code>*text</code></a> value on
    the left hand side in a way that is not <a href="#in-error">in error</a>,
    let the element's only child node be the attribute-forwarding text node.
    (If the element in question has any child nodes, then the <a
    href="#text"><code>*text</code></a> value will be <a href="#in-error">in
    error</a>.)

   <li>Replace any <a href="#content"><code>content</code></a> elements in
    the shadow tree with the nodes that were assigned to them in the <a
    href="#processing-content-elements0" title="Processing content
    Elements">previous section</a>, unless there are no such nodes, in which
    case replace them with their child nodes.

   <li>Replace the second and subsequent <a
    href="#inherited"><code>inherited</code></a> elements in the shadow tree
    with their child nodes.

   <li>Replace the first <a href="#inherited"><code>inherited</code></a>
    element in the shadow tree, if any, with the child nodes of the <a
    href="#next-most-derived">next most derived</a> binding's shadow tree's
    root <a href="#template"><code>template</code></a> element, or, if there
    is no less-derived binding with a shadow tree, with the child nodes of
    the <a href="#inherited"><code>inherited</code></a> element itself.

   <li>If the previous step added a shadow tree to the flattened tree, then
    return to step 3 to deal with that newly added shadow tree. Otherwise,
    move on to the next bound element.
  </ol>

  <div class=example>
   <p>Imagine the following document fragment:</p>

   <pre>...
 &lt;my:A xmlns:my="http://example.com/"&gt;
  &lt;my:B&gt;
   &lt;my:C/&gt;
   &lt;my:D/&gt;
  &lt;/my:B&gt;
 &lt;/my:A&gt;
...</pre>

   <p>...is bound to the following XBL:</p>

   <pre>...
 &lt;binding element="B" xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;template xmlns:my="http://example.com/"&gt;
   &lt;my:P&gt;
    &lt;my:Q&gt;
     &lt;content includes="C"&gt;
      &lt;my:R/&gt;
     &lt;/content&gt;
    &lt;my:/Q&gt;
    &lt;content includes="D"&gt;
     &lt;my:S/&gt;
    &lt;/content&gt;
   &lt;my:/P&gt;
  &lt;/template&gt;
 &lt;/binding&gt;
 &lt;binding element="Q"&gt;
  &lt;template&gt;
   &lt;my:X&gt;
    &lt;my:Y&gt;
     &lt;content&gt;
      &lt;my:Z1/&gt;
     &lt;/content&gt;
     &lt;content&gt;
      &lt;my:Z2/&gt;
     &lt;/content&gt;
    &lt;my:/Y&gt;
   &lt;my:/X&gt;
  &lt;/template&gt;
 &lt;/binding&gt;
...</pre>

   <p>The resulting DOM would look like the following. To read these
    diagrams, use the following key:</p>

   <pre>
      |    Solid/dashed lines represent normal DOM traversal attribute
   ---+--- relationships using childNodes, parentNode, nextSibling,
      |    previousSibling, firstChild, lastChild, etc.

      :
   ...:... Dotted lines represent the final flattened tree.
      :</pre>

   <p>White-space nodes have, for sanity, been left out of these diagrams.</p>

   <p>DOM view:</p>

   <pre>
   |
   +-- A
       |
       +-- B
           |
           +-- C
           |
           +-- D
</pre>

   <p>The shadow trees of B elements:</p>

   <pre>
   template
    |
    +-- P
        |
        +-- Q
        |   |
        |   +-- content
        |       |
        |       +-- R
        |
        +-- content
            |
            +-- S
</pre>

   <p>The shadow trees of Q elements:</p>

   <pre>
   template
    |
    +-- X
        |
        +-- Y
            |
            +-- content
            |   |
            |   +-- Z1
            |
            +-- content
                |
                +-- Z2
</pre>

   <p>The final flattened tree:</p>

   <pre>
   :
   :.. A
       :
       :.. B
           :
           :.. P
               :
               :.. Q
               :   :
               :   :.. X
               :       :
               :       :.. Y
               :           :
               :           :.. C
               :           :
               :           :.. Z2
               :
               :.. D
</pre>

   <p>The final flattened tree overlayed with the core DOM (the "*" and "#"
    characters here identify which <a
    href="#content"><code>content</code></a> elements the two explicit
    children are assigned to):</p>

   <pre id=pretty-diagram>
   :|___
   :....A      template
        :|___     |
        :... B    |
            :|    |
            :|... P       template
             |   :|____      |
             |   :|... Q     |
             |   :|   :|     |
             |   :|   :|.... X
             |   :|    |     :\_______
             |   :|    |     :....... Y __
             |   :|    |              :   \
             |   :|    +-- content*   :    |
             |   :|         |         :    |
             |   :|         +-- R     :    +-- content*
             |   :|                   :    |    |
             +---:|--------- C* ......:    |    `-- Z1
             |   :|                   :    |
             |   :|                   :    `-- content
             |   :|                   :         |___
             |   :|                   :............ Z2
             |   :`-- content#
             |   :     |
             |   :     `-- S
             |___:____
                 :... D#
</pre>
  </div>

  <h4 id=terminology><span class=secno>4.5.1. </span>Terminology</h4>

  <p>Shadow content introduces the concept of <dfn id=shadow-scope>shadow
   scope</dfn> to nodes within a document. Because shadow content elements
   can also have bindings attached that generate their own shadow content,
   this scoping can be taken to an arbitrary level of nesting.

  <p>Shadow content nodes are in <dfn
   id=binding-level-shadow-scopes>binding-level shadow scopes</dfn>. Binding
   scopes are determined by the bound element to which the binding
   responsible for the generation of the shadow nodes is attached. The bound
   element itself is in the shadow scope of the content around it, and its
   binding's shadow content is in a deeper shadow scope. Shadow content that
   contains no elements that are themselves bound is said to be in the
   deepest, or innermost, shadow scope.

  <h3 id=handling-dom-changes><span class=secno>4.6. </span><dfn
   id=handling-dom-changes0>Handling DOM Changes</dfn></h3>

  <p>All of the nodes in the shadow tree are live. Whenever an element is
   inserted into, removed from, or appended to the DOM, and whenever its
   attributes or pseudo-class states are changed, all the children of bound
   elements must check that their assigned <a
   href="#content"><code>content</code></a> element is still appropriate,
   following all the same rules that applied when first placing <a
   href="#explicit-children">explicit children</a> during shadow content
   generation. If one or more nodes stop fitting into any of the <a
   href="#content"><code>content</code></a> elements then they no longer
   appear in the <a href="#final-flattened-tree">final flattened tree</a>.
   Similarly, nodes that previously did not appear in the final flattened
   tree may start matching a <a href="#content"><code>content</code></a>
   element and thus be inserted into the flattened tree.

  <p>It is possible to manipulate the shadow content contained underneath a
   bound element using standard DOM APIs. If shadow content that contains a
   <a href="#content"><code>content</code></a> element is removed, then any
   <a href="#explicit-children">explicit children</a> assigned to that
   element are relocated to the first unlocked <a
   href="#content"><code>content</code></a> elements that match them. If a <a
   href="#content"><code>content</code></a> element's <a
   href="#includes"><code title=attr-content-includes>includes</code></a>
   attribute is changed, then the <a href="#explicit-children">explicit
   children</a> of the binding's bound element must be redistributed
   appropriately.

  <p><a href="#content"><code>content</code></a> elements may be dynamically
   locked by manipulating their <a href="#locked"><code
   title=attr-content-locked>locked</code></a> attribute. A locked <a
   href="#content"><code>content</code></a> element cannot accept new
   children unless they are explicitly assigned to it using the <a
   href="#setinsertionpoint"><code>setInsertionPoint()</code></a> method.
   However, children already under a locked <a
   href="#content"><code>content</code></a> element remain there while the
   element's <a href="#includes"><code
   title=attr-content-includes>includes</code></a> attribute (or lack
   thereof) matches them.

  <p>Whenever the subtree of a <a href="#template"><code>template</code></a>
   element in a binding document is dynamically modified, any shadow trees
   that were constructed by cloning that element must be <a
   href="#regenerating-a-shadow-tree">regenerated</a>.</p>
  <!-- XXX when does this happen,
  exactly, relative to the mutations? -->

  <h3 id=shadow-content-and-css><span class=secno>4.7. </span>Shadow Content
   and CSS</h3>

  <h4 id=selectors-and-shadow-scopes><span class=secno>4.7.1. </span><dfn
   id=selectors-and-shadow-scopes0>Selectors and Shadow Scopes</dfn></h4>

  <p>Bindings can interleave shadow elements between the bound element and
   its <a href="#explicit-children">explicit children</a>. (See: <a
   href="#processing-content-elements0">processing <code
   title="">content</code> elements</a>.) In this situation, a new tree
   emerges that is different from the explicit content node tree. In addition
   to having a single explicit parent (the bound element) and a single set of
   children (the explicit children in the DOM tree), elements also have a set
   of shadow parents and shadow children (introduced by bindings when <a
   href="#content"><code>content</code></a> elements were used). This
   necessarily affects the CSS model.

  <p><em>Combinators:</em> CSS combinators, in the presence of XBL, must act
   as follows. This is intended to match the definitions of CSS in all cases
   other than when a selector would involve one or more XBL elements.

  <dl>
   <dt>A&gt;B

   <dd>
    <p>If "<code>B</code>" is in a shadow tree and
     "<code>B.parentNode</code>" is a <a
     href="#content"><code>content</code></a> element or an <a
     href="#inherited"><code>inherited</code></a> element, let
     "<code>X</code>" be "<code>B.parentNode.parentNode</code>", otherwise
     let "<code>X</code>" be "<code>B.parentNode</code>".</p>

    <p>Now if "<code>X</code>" is the root of a shadow tree, but the
     binding's "<a href="#allow-selectors-through"><code
     title=attr-template-allow-selectors-through>allow-selectors-through</code></a>"
     is not <code>true</code>, the selector doesn't match "<code>B</code>".
     Otherwise, if "<code>X</code>" is the root of a shadow tree and the
     binding's "<a href="#allow-selectors-through"><code
     title=attr-template-allow-selectors-through>allow-selectors-through</code></a>"
     is <code>true</code> and the binding is the bound element's most derived
     binding with a shadow tree, then let "<code>X</code>" be the bound
     element for which the shadow tree was generated. Otherwise, if
     "<code>X</code>" is the root of a shadow tree and the binding's "<a
     href="#allow-selectors-through"><code
     title=attr-template-allow-selectors-through>allow-selectors-through</code></a>"
     is <code>true</code> but the binding is not the bound element's most
     derived binding with a shadow tree, then let "<code>X</code>" be the
     parent node of the <a href="#inherited"><code>inherited</code></a>
     element into which the shadow tree was placed during the construction of
     the <a href="#final-flattened-tree">final flattened tree</a>; if this is
     itself the root of a shadow tree, then repeat the steps described in
     this paragraph using that element as "<code>X</code>".</p>

    <p>Then, the selector matches "<code>B</code>" if the "<code>X</code>"
     element is the "<code>A</code>" element.</p>

   <dt>A&nbsp;B

   <dd>Matches "<code>B</code>" if either "<code>A&gt;B</code>" matches
    "<code>B</code>", or "<code>C&gt;B</code>" matches "<code>B</code>" and
    "<code>A&nbsp;C</code>" matches "<code>C</code>".

   <dt>A+B

   <dd>If "<code>B</code>" is in a shadow tree and
    "<code>B.previousSibling</code>" is a <a
    href="#content"><code>content</code></a> element or an <a
    href="#inherited"><code>inherited</code></a> element, the selector
    doesn't match "<code>B</code>", otherwise, it matches if
    "<code>B.previousSibling</code>" is "<code>A</code>".

   <dt>A~B

   <dd>Matches "<code>B</code>" if either "<code>A+B</code>" matches
    "<code>B</code>", or if "<code>C+B</code>" matches "<code>B</code>" and
    "<code>A~C</code>" matches "<code>C</code>".
  </dl>

  <div class=example>
   <p>The selector <code>p ~ p</code> never matches any elements in the
    following example, even if the <a
    href="#content"><code>content</code></a> element has a <code>p</code>
    element assigned to it:</p>

   <pre>&lt;template>
 &lt;p>...&lt;/p>
 &lt;content includes="p">&lt;p>...&lt;/p>&lt;/content>
 &lt;p>...&lt;/p>
&lt;/template>
   </pre>
  </div>

  <p><em>Pseudo-classes and pseudo-elements:</em> Pseudo-classes and
   pseudo-elements are unchanged in the presence of XBL. They operate
   exclusively on the core DOM.

  <div class=example>
   <p>In particular, note that this means that the selector
    <code>:nth-child(odd)</code> would match both <code>div</code> elements
    in the following example:</p>

   <pre>&lt;template>
 &lt;div>&lt;/div>
 &lt;content>&lt;/content>
 &lt;div>&lt;/div>
&lt;/template></pre>

   <p>...regardless of the number of nodes that are inserted at the point
    given by the <a href="#content"><code>content</code></a> element (whether
    that be 0, 1, 2, or more nodes).</p>
  </div>

  <h4 id=css-property-inheritance-and-rendering><span class=secno>4.7.2.
   </span><dfn id=css-property-inheritance-and-rendering0>CSS Property
   Inheritance and Rendering</dfn></h4>

  <p>The <a href="#final-flattened-tree">final flattened tree</a> determines
   how CSS properties (e.g., fonts and colors) are inherited. Elements must
   inherit from their parent node in the <a
   href="#final-flattened-tree">final flattened tree</a>, regardless of what
   their DOM Core parent node is.

  <p>Similarly, the rendering is performed using the <a
   href="#final-flattened-tree">final flattened tree</a>. Nodes that do not
   appear in the <a href="#final-flattened-tree">final flattened tree</a>
   have no computed style (as if they were orphan nodes) and are not
   rendered.

  <h4 id=the-bound-element-pseudo-class><span class=secno>4.7.3. </span>The
   <a href="#bound-element0"><code>:bound-element</code></a> Pseudo-Class</h4>

  <p>The <dfn id=bound-element0><code>:bound-element</code></dfn>
   pseudo-class, when used from a binding, must match the bound element of
   that binding. If the selector is used somewhere other than in a binding's
   style sheet (i.e. with a <code>style</code> element in XBL) or in a <a
   href="#content"><code>content</code></a> element's <a
   href="#includes"><code title=attr-content-includes>includes</code></a>
   attribute, then it must match any bound element. <a
   href="#refsSELECTORS">[SELECTORS]</a>

  <div class=example>
   <p>In the following example, the binding uses this pseudo-class to to draw
    a border around each of the children of the bound element, but no other
    elements:</p>

   <pre>&lt;binding>
 &lt;template>
  &lt;style scoped>
   :bound-element > * { border: solid; }
  &lt;/style>
  &lt;content allow-selectors-through="true">&lt;/content>
 &lt;/template>
&lt;/binding></pre>
  </div>

  <h4 id=matching-pseudo-elements><span class=secno>4.7.4. </span><dfn
   id=matching-pseudo-elements0>Matching Pseudo-Elements</dfn></h4>

  <p>Shadow nodes may be associated with various pre-defined <a
   href="#pseudo-element" title=pseudo-element>pseudo-elements</a> of the
   bound element. On any element in the shadow content template, an <a
   href="#pseudo"><code title=attr-pseudo>pseudo</code></a> attribute (in the
   XBL namespace) can be used to specify the name of the pseudo to associate
   with that element.

  <div class=example>
   <p>For example, once more returning to the HTML file upload control
    example above, the shadow text field can be set up to be considered a
    match for the selector <span>input[type=file]::value</span> as follows.</p>

   <pre>&lt;binding id="fileUploadControl"&gt;
  &lt;template&gt;
    &lt;input type="text" pseudo="value"/&gt;
    &lt;input type="button" value="Browse..."/&gt;
  &lt;/template&gt;
&lt;/binding&gt;</pre>
  </div>

  <p>The pseudo must be given without its leading double colon.

  <p>If the pseudo-element name is not recognized, it is <a
   href="#in-error">in error</a> and the UA must <a
   href="#ignoring">ignore</a> the attribute. User agents must not
   automatically recognize any pseudo-element (as this will break
   forwards-compatibility).

  <p>If an element has multiple nodes with the same pseudo-element, then they
   all match the relevant selector. Matching of nodes based on their
   pseudo-element is unaffected by the <code>apply-author-sheets</code>
   attribute.

  <p id=pseudo-list>The allowed pseudo-elements are:

  <dl>
   <dt>::value

   <dd>Intended to represent the entire rectangular 'interactive area' (or
    the nearest equivalent in non-visual environments) of a text-entry form
    control, specifically excluding the caption.

   <dt>::choices

   <dd>Intended to represent the entire rectangular 'selection area' (or the
    nearest equivalent in non-visual environments) of a list form control,
    specifically excluding the caption.

   <dt>::label

   <dd>Intended to represent the non-interactive area (or the nearest
    equivalent in non-visual environments) of control, typically the caption.

   <dt>::repeat-item

   <dd>Within a repeating sequence, each repeated item could be labeled as
    matching a pseudo-element ::repeat-item.

   <dt>::icon

   <dd>Intended to represent the icon part of a control, for example the
    picture in a toolbar button or the icon next to a menu item.</dd>
   <!--
    <dt>::XXX</dt>

    <dd>Intended to represent a specific part (or the nearest equivalent
    in non-visual environments) of a XXX control.</dd>
  -->
   <!-- XXX add more from css3-ui -->
  </dl>

  <p>These pseudo-element descriptions are purely advisory, and while authors
   are encouraged to use them for their predefined roles, it is valid to use
   them for other purposes.

  <div class=example>
   <p>The following XBL is part of the definition of a button control.</p>

   <pre>&lt;binding id="imageButton"&gt;
  &lt;template&gt;
    &lt;span pseudo="icon"&gt;&lt;/span>
    &lt;span attributes="*text=title"&gt;&lt;/span>
  &lt;/template&gt;
&lt;/binding&gt;</pre>

   <p>This control could then be used like this:</p>

   <pre>&lt;button title="Save" class="save-button"/&gt;</pre>

   <p>...and styled like this:</p>

   <pre>button { binding: url(buttons.xbl#imageButton); }
button.save-button::icon {
   content: url(icons/save.png);
}</pre>
  </div>

  <p>In property descriptions, the term "all elements" in the "Applies To:"
   line includes these pseudo-elements, as they map directly to real elements
   in the binding.

  <p>User agents are required to support the above pseudo-element
   identifiers, in so far as they interact with XBL2. User agents may also
   support these same pseudo-elements for other purposes, e.g. as described
   in the CSS3 UI specification. <a href="#refsCSS3UI">[CSS3UI]</a>

  <h3 id=shadow-content-and-xmlbase><span class=secno>4.8. </span>Shadow
   Content and <code>xml:base</code></h3>

  <p class=note>This section is intended to re-iterate what the
   <code>xml:base</code> specification already states, in case there is any
   question about how <code>xml:base</code> processing should work in shadow
   trees.

  <p>Relative <code>xml:base</code>s on nodes in shadow trees are resolved
   relative to their <code>parentNode</code>, or the
   <code>ownerDocument</code> if there is no <code>parentNode</code>.

  <h3 id=shadow-content-and-other-things><span class=secno>4.9. </span><dfn
   id=shadow-content-and-other-things0 title="Semantics of non-XBL elements
   in XBL contexts">Shadow Content and Other Things</dfn></h3>
  <!--XXX Things that need to be defined in future revisions include
  <em>binding to</em> html:script, html:select, html:textarea, MathML
  nodes, etc (are their semantics based on the shadow tree, the
  <span>final flattened tree</span>, or the original tree), as well as
  having elements inside the shadow tree such as html:script,
  html:style, html:map, form controls (are they part of the outer
  form), html:form (does it wrap elements that are assigned to
  <code>content</code> elements?), etc. -->

  <h4 id=general-rules><span class=secno>4.9.1. </span>General Rules</h4>

  <p>Shadow content is not considered part of a document, so elements that
   are defined to trigger when they are "inserted into the document" do not
   trigger during binding attachment.

  <p>IDs used in shadow content, as seen on XML Events nodes, in XHTML on the
   <code>html:label</code> element's <code>for</code> attribute, and in many
   other places, must be resolved in the context of the <a
   href="#shadow-scope">shadow scope</a> and (failing that) the binding
   document, not the scope of the document into which the shadow content is
   inserted.

  <div class=example>
   <p>If a shadow template has an <code>html:img</code> element that has its
    <code>usemap</code> attribute set:</p>

   <pre>&lt;template ...>
  &lt;img src="..." usemap="#test" alt="...">
&lt;/template></pre>

   <p>If the binding is applied to an element in a document containing a
    <code>map</code> element with ID "test", that image map will not be
    associated with this image. If the binding document itself contains a
    <code>map</code> element with ID "test", however, that <em>would</em> be
    associated with the element (even if it was, say, in another binding's
    template).</p>

   <p>If the template looked like this:

   <pre>&lt;template ...>
  &lt;img src="..." usemap="#test" alt="...">
  &lt;map id="test"> ... &lt;/map>
&lt;/template></pre>

   <p>...then the <code>img</code> element would always be attached to that
    <code>map</code> element, regardless of the existence of other
    <code>map</code> elements in the binding document.</p>
  </div>

  <p>When an element's processing model is defined in terms of the element's
   child nodes or descendants, shadow trees do not affect the processing
   model (unless this is called out explicitly below). For instance, an HTML
   <code>title</code> element's behavior in determining the document title is
   unaffected by XBL, even if the <code>title</code> element is bound or has
   bound elements in its descendants.

  <p>When the nodes are cloned, their <code>xml:base</code> data remains as
   it was in the bindings document (see <span>rules for content
   generation</span>). Therefore URIs consisting of just fragment identifiers
   (such as those in <code>url()</code> notation in <code
   title="">style</code> attributes of, e.g., HTML nodes) refer to resources
   in the bindings document, not content in the bound document or the shadow
   tree.

  <p class=note>This would cause trouble with <a
   href="#attribute-forwarding0">attribute forwarding</a>, so the attribute
   forwarding syntax allows attributes to be marked as being <a href="#url"
   title=type-url>of type "url"</a>.

  <h4 id=style-blocks><span class=secno>4.9.2. </span><dfn
   id=style-blocks0>Style Blocks</dfn></h4>

  <p>The semantics of <code>style</code> elements (absent their <code
   title=attr-style-scope>scope</code> attribute) is that they introduce new
   styles for their document. Since the document, in the case of anything in
   a shadow tree, is the binding document, <em>that</em> is the document that
   must be affected by such a style sheet.

  <p>Since the style sheets of such resource documents generally have no
   effect, placing <code>style</code> blocks in binding documents (without a
   <code title=attr-style-scope>scope</code> attribute) is usually redundant.
   Such an element placed in a shadow content template does not affect the
   documents into which the shadow content is later inserted during binding
   attachment.

  <p>The <code>style</code> element is used <em>with</em> its <code
   title=attr-style-scope>scope</code> attribute as a child of a <a
   href="#template"><code>template</code></a> to provide styles for bindings,
   leveraging HTML's intrinsic semantics.

  <h4 id=script-blocks><span class=secno>4.9.3. </span><dfn
   id=script-blocks0>Script Blocks</dfn></h4>

  <p>Script elements, such as the HTML <code>script</code> element and its
   ilk, are typically evaluated only during parsing, or during parsing and
   when inserted into a document. In all cases, however, they are evaluated
   in the context of their owner document. Therefore such elements must only
   be evaluated during initial parsing, in the context of the binding
   document, and not during binding attachment.

  <h4 id=html-forms><span class=secno>4.9.4. </span>HTML Forms</h4>

  <p>Forms and form controls in shadow trees don't interact with form
   controls and <code>form</code> elements in the bound document. Each
   document and shadow tree creates a new scope for forms and form controls.

  <div class=example>
   <p>Here's an extract from an HTML document with a form:</p>

   <pre>...
&lt;form action="register" method="post">
 &lt;h2>Customer Registration&lt;/h2>
 &lt;p>Please enter your details.&lt;/p>
 &lt;fieldset>
  &lt;legend>Contact Information&lt;/legend>
  &lt;p>Name: &lt;input name="name" title="Enter your full name (first name first).">&lt;/p>
  &lt;p>Job Title: &lt;input name="title" title="Enter your job title, e.g. 'Software Engineer'.">&lt;/p>
  &lt;p>E-mail: &lt;input name="email" title="Enter your e-mail address, in the form 'user@example.com'.">&lt;/p>
 &lt;/fieldset>
 &lt;fieldset>
  &lt;legend>Company Information&lt;/legend>
  &lt;p>Name: &lt;input name="company" title="Enter the name of your employer.">&lt;/p>
  &lt;p>Address: &lt;textarea name="address" title="Enter the full street address of your employer, including postal code.">&lt;/p>
 &lt;/fieldset>
 &lt;fieldset>
  &lt;legend>Additional Information&lt;/legend>
  &lt;p>Birthday: &lt;input name="dob" title="Enter your birthdate in the form YYYY-MM-DD, e.g. 1975-03-29.">&lt;/p>
  &lt;p>Favorite animal: &lt;input name="animal" title="Enter the word 'Cat'.">&lt;/p>
 &lt;/fieldset>
 &lt;fieldset>
  &lt;legend>Submission&lt;/legend>
  &lt;p>&lt;button title="Only submit the form when you are sure it is complete.">Submit&lt;/button>&lt;/p>
 &lt;/fieldset>
&lt;/form>
...</pre>

   <p>The first binding below could be attached to the <code>form</code>
    above, through CSS, to provide a help box that shows the help text
    associated with the currently focused control:</p>

   <pre>...
&lt;binding id="form-with-help">
 &lt;template>
  &lt;style scoped>
   .header { font-size: larger; }
   .form { height: 15em; overflow: scroll; }
  &lt;/style>
  &lt;div>
   &lt;div class="header">Form:&lt;/div>
   &lt;div class="form">&lt;content>&lt;/content>&lt;/div>
  &lt;/div>
  &lt;div>
   &lt;div class="header">Help:&lt;/div>
   &lt;div id="help">&lt;/div>
  &lt;/div>
 &lt;/template>
 &lt;implementation>
  ({ xblBindingAttached: function () {
       this.addEventListener('focus', function (event) {
         this.shadowTree.getElementById('help').textContent = event.target.getAttribute('title');
       }, false);
     },
  })
 &lt;/implementation>
&lt;/binding>
...</pre>

   <p>The help could be positioned more usefully by a slightly more advanced
    binding that positioned the <code>div</code> when setting the help.</p>

   <p>The last binding isn't particularly interesting. However, the important
    thing to note is that if it was extended to include form controls of its
    own, as in the following example, the form controls in the binding would
    not interact with the form in the markup:</p>

   <pre>...
&lt;binding id="form-with-help">
 &lt;template>
  &lt;style scoped> ... &lt;/style>
  &lt;div class="header">
   &lt;div class="title">&lt;content includes=":bound-element > h2:first-of-type">&lt;/content>&lt;/div>
   &lt;div class="tagline">&lt;content includes=":bound-element > h2:first-of-type ~ p:first-of-type">&lt;/content>&lt;/div>
  &lt;/div>
  &lt;div>
   &lt;div class="panel">&lt;content locked="true" id="current">&lt;/content>&lt;/div>
  &lt;/div>
  &lt;div>
   &lt;div class="buttons">
    &lt;button id="back">Back&lt;/button>
    &lt;button id="next">Next&lt;/button>
   &lt;/div>
  &lt;/div>
  &lt;div class="hidden">&lt;content includes=":bound-element > fieldset" id="not-current">&lt;/content>&lt;/div>
 &lt;/template>
 &lt;implementation>
  ({
    set current(fieldset) {
      if (this._current)
        this.shadowTree.getElementById('not-current').setInsertionPoint(this._current);
      this._current = fieldset;
      if (this._current)
        this.shadowTree.getElementById('current').setInsertionPoint(this._current);
    },
    back: function() {
      if (!this._current) return;
      var notCurrent = this.shadowTree.getElementById('not-current');
      notCurrent.setInsertionPoint(this._current);
      var last = this._current;
      var index = 0;
      while (index &amp;lt; notCurrent.xblChildNodes.length &&
             notCurrent.xblChildNodes[index] != this._current)
        last = notCurrent.xblChildNodes[index++];
      this._current = last;
      this.shadowTree.getElementById('current').setInsertionPoint(this._current);
    }
    next: function() {
      if (!this._current) return;
      var notCurrent = this.shadowTree.getElementById('not-current');
      notCurrent.setInsertionPoint(this._current);
      var last = this._current;
      var index = notCurrent.xblChildNodes.length-1;
      while (index > 0 && notCurrent.xblChildNodes[index] != this._current)
        last = notCurrent.xblChildNodes[index++];
      this._current = last;
      this.shadowTree.getElementById('current').setInsertionPoint(this._current);
    }
    get current() {
      return this._current;
    },
    xblBindingAttached: function() {
      this.current = this.getElementById('not-current').xblChildNodes[0];
      this.shadowTree.getElementById('back').addEventListener('click', this.back, false);
      this.shadowTree.getElementById('next').addEventListener('click', this.next, false);
    },
  })
 &lt;/implementation>
&lt;/binding>
...</pre>

   <p>Again, the binding could be made cleaner, e.g. by disabling the "back"
    button when on the first page, and by hiding the last fieldset and
    instead having a "finish" button, but these improvements are left as
    exercises for the reader.</p>
  </div>

  <h4 id=svg><span class=secno>4.9.5. </span>SVG</h4>

  <p><em>Painting:</em> When painting groups, for child elements that have
   shadow trees, instead of painting the child element itself, the group must
   paint the child nodes of the element's shadow tree's root <a
   href="#template"><code>template</code></a> element.

  <p><a href="#text"><em>Text:</em></a> When rendering text, for descendant
   elements that have shadow trees, instead of using the element or its
   children directly, the user agent must use the child nodes of the
   element's shadow tree's root <a href="#template"><code>template</code></a>
   element. (All other processing, e.g. handling of combining characters,
   must then be done as defined for SVG.)

  <p><em>ID references and URIs:</em> When a URI identifies an element with a
   shadow tree, the SVG processor must use the first element node in the
   element's shadow tree's root <a href="#template"><code>template</code></a>
   element's <code>childNodes</code> list instead of the element itself. If
   there are no elements, then the SVG document is in error. The SVG
   specification defines how to handle documents that are in error.</p>
  <!-- NOT links to "in error", since this is
  SVG-in-error, not XBL-in-error. -->

  <p>When a URI reference with a fragment identifier in a shadow tree
   references the binding document, then, if an elemnt in the shadow tree is
   identified by the fragment identifier, that is the element that must be
   used; otherwise, the fragment identifier must be matched against the
   actual binding document instead.

  <p><em>Animation elements:</em> When an animation element would be
   implicitly associated with its parent element (e.g. when it has no <code
   title="">xlink:href</code> attribute), but that parent element is a <a
   href="#template"><code>template</code></a> element that is the root of a
   shadow tree, then the animation element must instead be associated with
   the element found using the following algorithm:

  <ol>
   <li>Let <var title="">element</var> be the animation element.

   <li>If <var title="">element</var> has no parent element, then the
    animation element is not associated with any element. Stop these steps.

   <li>Let <var title="">parent</var> be the parent element of <var
    title="">element</var>.

   <li>If <var title="">parent</var> is a <a
    href="#template"><code>template</code></a> element that is the root of a
    shadow tree, then let <var title="">element</var> be the bound element
    for that shadow tree, and return to the second step.

   <li>Otherwise, <var title="">parent</var> is the element to which the
    animation element is assigned.
  </ol>

  <p>Animation elements must be processed even when in shadow trees.

  <div class=example>
   <p>In the following example, the UA would render the string "Hello Cruel
    World", while animating the colour of the entire string over six seconds.</p>

   <pre>&lt;svg xmlns="http://www.w3.org/2000/svg">
  &lt;defs>
    &lt;html:binding <a href="#element" title=attr-binding-element>element="world"</a> xmlns:b="http://www.w3.org/1999/xhtml">
      &lt;html:template>
        &lt;tspan <a href="#attributes4" title=attr-attributes>attributes</a>="<a href="#text" title="*text">*text=data</a>"/> World
        &lt;animateColor attributeName="fill" from="rgb(0,0,255)" to="rgb(128,0,0)" begin="0s" dur="6s" fill="freeze" />
      &lt;/html:template>
    &lt;/html:binding>
  &lt;/defs>
  &lt;text y="50" font-size="12">
    Hello &lt;world xmlns="" data="Cruel"/>
  &lt;/text>
&lt;/svg></pre>
  </div>

  <h3 id=binding-style-sheets><span class=secno>4.10. </span><dfn
   id=binding-style-sheets0>Binding Style Sheets</dfn></h3>

  <p>Shadow content nodes and bound elements are styled using style sheets
   from a number of sources, depending on the values of certain attributes.
   When multiple bindings are applied to the same bound element, the sheets
   from each binding all contribute to the final set of style sheets to
   apply, the style sheets of the <a href="#most-derived-binding">most
   derived binding</a> being walked first. For each binding, the style sheets
   that apply are as follows, in the order given:

  <p><em>Scoped style sheets:</em> A binding file can load style sheets using
   the <code>style</code> element. (See: <span>loading style sheets</span>.)
   These style sheets must be applied to the bound element and to all shadow
   content attached to the bound element.

  <p>If the binding was attached using CSS, the scoped style sheets have the
   same CSS origin as the sheet with the rule responsible for the binding.
   Style sheets used by bindings that are attached using the DOM or using <a
   href="#importing-binding-documents0"><code
   title=import>&lt;?xbl?&gt;</code></a> are treated as author-level sheets.

  <p>When bindings from multiple levels are applied to the same bound
   element, the style sheets that apply must cascade according to their own
   levels.

  <p class=example>An element E is attached to binding U from the user agent
   style sheet, and binding A from the DOM, which places A in the author
   level. When the style sheets that apply to E are sorted, U must be applied
   at the UA level and A at the author level.

  <p><a href="#author-style-sheets"><em>Author style sheets</em></a>: While
   the <a href="#apply-author-sheets"><code
   title=attr-template-apply-author-sheets>apply-author-sheets</code></a>
   attribute on the <a href="#template"><code>template</code></a> element
   found at the root of the element's shadow tree is set to
   <code>true</code>, the rules specified in any <a
   href="#author-style-sheets">author style sheets</a> at <a
   href="#shadow-scope" title="shadow scope">outer shadow scopes</a>
   (including those promoted to outer scopes using <a
   href="#apply-binding-sheets"><code
   title=attr-content-apply-binding-sheets>apply-binding-sheets</code></a>,
   as defined below) must be applied to the shadow content. Otherwise, only
   those matched through <a href="#pseudo-list">predefined
   pseudo-elements</a> are used, and other author-level sheets in higher
   shadow scopes must not be applied to the shadow content. (The bound
   element is always styled using the sheets of higher shadow scopes.)

  <p>By default, style sheets specified in bindings (as described above) are
   applied only to shadow content generated by bindings attached to the bound
   element and to the bound element itself. A second attribute, <a
   href="#apply-binding-sheets"><code
   title=attr-content-apply-binding-sheets>apply-binding-sheets</code></a>,
   can be used to indicate that all descendants of the bound element, both
   shadow and explicit, can be styled by the sheets in the binding's
   document. This can be controlled on a per-insertion-point basis. While
   this attribute is set to <code>true</code> on a <a
   href="#content"><code>content</code></a> node in the shadow tree DOM, any
   nodes that are assigned to that element, and any descendants of those
   nodes, must have the scoped style sheets of the binding (those that apply
   to the shadow content as described above) applied to them too, as if they
   had been promoted to the higher scope.

  <p>Sheets within each origin are always walked from the innermost shadow
   scope to the outermost shadow scope (with rules in the outermost shadow
   scope therefore overriding rules of equal specificity in the innermost
   shadow scope). With this ordering a binding that defines a widget can
   define a default look for the widget that can then be easily overridden by
   a client of the widget. For multiple bindings attached to the same
   element, the sheets are walked from the <a href="#base-binding">base
   binding</a> to the <a href="#most-derived-binding">most derived
   binding</a>.

  <p><em><a href="#user-agent-style-sheets">User agent style sheets</a> and
   <a href="#user-style-sheets">user style sheets</a></em>: These are always
   applied to all shadow scopes.

  <p>Since styles from both author style sheets and binding style sheets are
   applied to the bound element, it is possible for an infinite loop to form
   where an author sets the '<a href="#binding1"><code title="binding
   property">binding</code></a>' property to a particular binding that then
   explicitly sets the '<a href="#binding1"><code title="binding
   property">binding</code></a>' property to 'none' (or another binding).
   This specification does not take any precautions to avoid this, any more
   than it takes precautions to avoid loops caused by binding constructors
   explicitly calling <a
   href="#removebinding"><code>removeBinding()</code></a> to remove the
   binding itself and binding detachment event handlers reattaching the
   bindings. Similar potential loops exist also in underlying technologies,
   for example <code>:hover</code> rules that cause elements to no longer be
   hovered, or focus event handlers that move focus to an element and blur
   event handlers that move focus back to the element.

  <p>In so far as XBL is concerned, authors must avoid constructing such
   loops, and implementers must ensure that such loops do not prevent users
   from interacting with the user agent.

  <h4 id=styleSummary><span class=secno>4.10.1. </span>Summary of styling
   rules</h4>

  <p><em>This section is non-normative.</em>

  <p>The <code>&lt;style&gt;</code> element, with its <code
   title=attr-style-scope>scope</code> attribute, is applied to the bound
   element and the shadow content that was generated by the binding. Its
   styles are also applied to explicit children (and their descendants)
   assigned to <code>&lt;content&gt;</code> elements whose <a
   href="#apply-binding-sheets"><code
   title=attr-content-apply-binding-sheets>apply-binding-sheets</code></a> is
   set to <code>true</code>.

  <p>Continuing from the above, author sheets (styles from the bound
   document) are applied to the shadow content only if <a
   href="#apply-author-sheets"><code
   title=attr-template-apply-author-sheets>apply-author-sheets</code></a> is
   set to true for the <code>&lt;template&gt;</code>.

  <p>Last, but not least, one can use author sheets to change the style of
   elements in the shadow content that use the <a href="#pseudo"><code
   title=attr-pseudo>pseudo</code></a> attribute, as long as it matches them
   with pseudo-elements (irrespective of the <a
   href="#apply-author-sheets"><code
   title=attr-template-apply-author-sheets>apply-author-sheets</code></a>
   setting).
<!--
  <h2 id=binding-implementations><span class=secno>5. </span><dfn
   id=binding-implementations0>Binding Implementations</dfn></h2>

  <p>Bindings can define methods and properties on a bound element using the
   <a href="#implementation"><code>implementation</code></a> element. A
   binding implementation provides a new set of methods and properties that
   can be invoked from the bound element.

  <p>In general, each binding has an object that implements the <a
   href="#xblimplementation"><code>XBLImplementation</code></a> interface,
   along with any other interfaces that the implementation might implement.
   This is the <em>implementation object</em> for that instance of the
   binding. All elements implement the <a
   href="#elementxbl"><code>ElementXBL</code></a> interface, whose <a
   href="#xblimplementations"><code>xblImplementations</code></a> member
   returns an object implementing <a
   href="#xblimplementationlist"><code>XBLImplementationList</code></a>. This
   object lists all the implementation objects for that bound element. (If
   the element is not a bound element, the list is empty.)

  <h3 id=the-xblimplementation-interface><span class=secno>5.1. </span>The <a
   href="#xblimplementation"><code>XBLImplementation</code></a> Interface</h3>

  <p>All implementation objects support the <a
   href="#xblimplementation"><code>XBLImplementation</code></a> interface (in
   addition to any other interfaces specific to the binding). By implementing
   the methods defined in this interface, bindings can be notified of the
   binding's state with respect to its environment.

  <pre
   class=idl>interface <dfn id=xblimplementation>XBLImplementation</dfn> {
  void <a href="#xblbindingattached">xblBindingAttached</a>();
  void <a href="#xblentereddocument">xblEnteredDocument</a>();
  void <a href="#xblleftdocument">xblLeftDocument</a>();
};</pre>

  <p>The <dfn id=xblbindingattached><code>xblBindingAttached()</code></dfn>
   method is called by the user agent after the binding has been attached.
   (See: <a href="#binding-attachment-model0">binding attachment model</a>.)

  <p>The <dfn id=xblentereddocument><code>xblEnteredDocument()</code></dfn>
   method is called by the user agent in two cases:

  <ul>
   <li> When the bound element, or one of its ancestors, or one of the
    elements in a higher shadow scope, is inserted into the document.

   <li> When the binding is originally attached, if the bound element is
    already in the document.
  </ul>

  <p>Thus, it can be used to perform initialization steps that depend upon
   being in a document. (See: <a href="#binding-attachment-model0">binding
   attachment model</a>, <a
   href="#handling-insertion-and-removal-from-the-0">handling insertion and
   removal from the document</a>.)

  <p>The <dfn id=xblleftdocument><code>xblLeftDocument()</code></dfn> method
   is called by the user agent when the bound element, or one of its
   ancestors, or one of the elements in a higher shadow scope, is removed
   from the document. (See: <a
   href="#handling-insertion-and-removal-from-the-0">handling insertion and
   removal from the document</a>.)

  <p>If the <a href="#implementation"><code>implementation</code></a> does
   not define one of these methods, then when that method is invoked, nothing
   must happen (as if all bindings had default implementations of those
   methods that were no-ops).</p>
  --><!-- XXX need a way to persist certain values --><!--

  <p>Authors should not start their own methods with the three letters "xbl".
   Future versions of this specification might add new callbacks to this
   interface, and if they do, those methods will start with the prefix "xbl".</p>
  --><!-- XXX more callbacks:
    http://lxr.mozilla.org/seamonkey/source/content/xtf/public/nsIXTFStyledElementWrapper.idl
    xblSelected to indicate that the selection now spans the element (glazou)
   --><!--

  <div class=example>
   <p>This binding implements a clock. However, to save resources, the clock
    is only active when it is actually included in a document.</p>

   <pre>
&lt;binding id="clock">
 &lt;implementation>
   ({
    xblEnteredDocument: function () {
      this.timer = setInterval(update, 1000);
    },
    xblLeftDocument: function () {
      clearInterval(this.timer);
    },
    update: function () {
      this.shadowTree.getElementById('clock-value').textContent = new Date();
    },
   })
 &lt;/implementation>
 &lt;template>&lt;div id="clock-value">&lt;/div>&lt;/template>
&lt;/binding></pre>
  </div>

  <h3 id=the-xblimplementationlist-interface><span class=secno>5.2.
   </span>The <a
   href="#xblimplementationlist"><code>XBLImplementationList</code></a>
   Interface</h3>

  <p>The <dfn id=xblimplementations><code>xblImplementations</code></dfn>
   attribute on all elements must return an instance of an <a
   href="#xblimplementationlist"><code>XBLImplementationList</code></a>
   object (the same object for the lifetime of the element), which is a live
   list of the implementation objects provided by the bindings for that bound
   element at any particular point in time.

  <pre
   class=idl>interface <dfn id=xblimplementationlist>XBLImplementationList</dfn> {
  <a href="#xblimplementation">XBLImplementation</a> <a href="#itemn" title=XBLImplementationList-item>item</a>(in unsigned long index);
  readonly attribute unsigned long <a href="#length" title=XBLImplementationList-length>length</a>;
};</pre>

  <p>The <dfn id=length
   title=XBLImplementationList-length><code>length</code></dfn> attribute
   must return the number of implementation objects associated with the bound
   element, or zero if the element is not a bound element or has none of its
   bindings have implementations.

  <p>The <dfn id=itemn
   title=XBLImplementationList-item><code>item(<var>n</var>)</code></dfn>
   method must return the <var>n</var>th implementation object associated
   with the bound element. If the index is not a number between zero and <a
   href="#length"><code
   title=XBLImplementationList-length>length</code></a>-1 (inclusive), then
   the method must raise an <code>INDEX_SIZE_ERR</code> DOM exception. <a
   href="#refsDOM3CORE">[DOM3CORE]</a>

  <p>The list must be ordered such that the <a
   href="#most-derived-binding">most derived binding</a> is last, and the <a
   href="#base-binding">base binding</a> has index zero.

  <p>Objects that implement the <a
   href="#xblimplementationlist"><code>XBLImplementationList</code></a>
   interface must also have a [[Get]] method that, when invoked with a
   property name that is a number, acts like the <a href="#itemn"><code
   title=XBLImplementationList-item>item()</code></a> method would when
   invoked with that argument.

  <h3 id=accessing-binding-implementations><span class=secno>5.3.
   </span>Accessing Binding Implementations</h3>

  <p>Script can access binding implementations directly using the <a
   href="#xblimplementations"><code>xblImplementations</code></a> member. In
   addition, any attempts to access members of <a
   href="#elementxbl"><code>ElementXBL</code></a> objects that do not
   correspond to methods or properties on the object itself but do correspond
   to members of one of the objects in the <a
   href="#xblimplementations"><code>xblImplementations</code></a> list must
   be forwarded to the last object in the <a
   href="#xblimplementations"><code>xblImplementations</code></a> list that
   is so matched.</p>
  --><!-- XXX example needed, including one that shows this with an
  lvalue --><!--

  <h3 id=creation-of-implementations><span class=secno>5.4. </span>Creation
   of Implementations</h3>

  <p>When a binding is attached, the user agent must follow the following
   steps to make the binding implementation available to scripts:

  <ol>
   <li>
    <p>If this is the first time the binding defined by that <a
     href="#binding0"><code>binding</code></a> element is used since that
     binding document was loaded, and if that element contains an <a
     href="#implementation"><code>implementation</code></a> element, and if
     the <a href="#binding0"><code>binding</code></a> element does not have
     an <i>implementation prototype object</i>, then:</p>

    <ol>
     <li>The first <a href="#implementation"><code>implementation</code></a>
      element child of the <a href="#binding0"><code>binding</code></a>
      element must have its code <a href="#compiling-bindings0"
      title="Compiling Bindings">compiled and run</a> (see below).

     <li>The return value of that script, if it is an object, must be forever
      associated with that <a href="#binding0"><code>binding</code></a>
      element as that binding's <i>implementation prototype object</i>.
    </ol>

    <p>Otherwise, if the <a href="#binding0"><code>binding</code></a> element
     doesn't contain an <a
     href="#implementation"><code>implementation</code></a> element, or if it
     does but it does not evaluate to an object, then an empty object must be
     created (by invoking the <code>Object</code> constructor in the global
     scope of the binding document), and the <a
     href="#binding0"><code>binding</code></a> element's <i>implementation
     prototype object</i> must be forever set to that object.</p>

    <p class=note>Any further changes to <a
     href="#implementation"><code>implementation</code></a> elements will
     have no effect on the <i>implementation prototype object</i> of this
     particular binding.</p>

   <li>
    <p>Next, the UA must create two new ECMAScript objects by invoking the
     <code>Object</code> constructor in the global scope of the binding
     document. These objects are the <dfn id=internal-object>internal
     object</dfn> and the <dfn id=external-object>external object</dfn>.</p>

   <li>
    <p>The [[Prototype]] property of the internal object must be set to the
     external object, and the [[Prototype]] property of the external object
     must be set to the binding's <i>implementation prototype object</i>.</p>

   <li>
    <p>The internal object must then have the following fields defined:</p>

    <dl>
     <dt><dfn id=external><code>external</code></dfn>

     <dd>This field's value must be set to a reference to the external
      object.

     <dt><dfn id=boundelement><code>boundElement</code></dfn>

     <dd>This field's value must be set to a reference of the node object
      that is the bound element.

     <dt><dfn id=shadowtree><code>shadowTree</code></dfn>

     <dd>This field's value must be initially set to null. Its value is
      changed during <a href="#rules-for-shadow-content-generation0"
      title="Rules for Shadow Content Generation">shadow content
      generation</a> and <a href="#rules-for-shadow-content-destruction0"
      title="Rules for Shadow Content Destruction">destruction</a>.

     <dt><dfn id=basebinding><code>baseBinding</code></dfn>

     <dd>If the binding's <a href="#extends"><code
      title=attr-binding-extends>extends</code></a> attribute caused another
      binding to be attached to the bound element, then the <a
      href="#basebinding"><code>baseBinding</code></a> field's value must be
      set to a reference of that binding's implementation object, if it has
      one (if that is an ECMAScript implementation as well, then that is that
      binding's external object). Otherwise, it must be set to the value
      null.
    </dl>

    <p>It must also implement the <code>EventTarget</code> interface.</p>
  </ol>

  <p>Conceptually, the internal and external objects together make the
   implementation object, but as far as the <a
   href="#xblimplementations"><code>xblImplementations</code></a> property's
   list is concerned, the external object is the one that is returned as the
   implementation object.

  <h4 id=compiling-bindings><span class=secno>5.4.1. </span><dfn
   id=compiling-bindings0>Compiling Bindings</dfn></h4>

  <p>When the user agent has to compile and run an XBL binding ECMAScript
   implementation, it must first obtain the script itself in the manner
   described in the section on <a
   href="#loading-and-running-scripts0">loading and running scripts</a>, and
   must then compile and execute the script using the binding document's
   global scope.

  <p>If the script evaluates to an object, then that is the <i>implementation
   prototype object</i>. Otherwise, there isn't one.

  <h4 id=invoking-methods-on-an-implementation-ob><span class=secno>5.4.2.
   </span>Invoking Methods on an Implementation Object</h4>

  <p>When function code of an implementation object is called, the user agent
   must set the <code>this</code> value to the <a
   href="#internal-object">internal object</a> associated with the <a
   href="#external-object">external object</a> on which the function was
   invoked.
-->
  <h2 id=event-handlers><span class=secno>6. </span><dfn
   id=event-handlers0>Event Handlers</dfn></h2>

  <h3 id=event-forwarding><span class=secno>6.1. </span><dfn
   id=event-forwarding0>Event Forwarding</dfn></h3>

  <p>Whenever an event passes through a bound element, whether during the
   capture, target, bubble, or <a href="#the-default-phase0" title="default
   phase">default</a> phases, the user agent must also invoke any appropriate
   event listeners attached to the binding's <a
   href="#internal-object">internal object</a>.

  <p>When events are forwarded in this manner, the event handlers attached to
   the <a href="#internal-object">internal object</a> must fire after any
   event handlers on the bound element itself in the capture phase, after the
   event has been retargeted to shadow nodes, if appropriate; and before any
   event handlers on the bound element itself in the target and bubble
   phases, before the event has been retargeted to the bound element, if
   appropriate. (See: <a
   href="#event-flow-and-targeting-across-shadow-s0">event flow and targeting
   across shadow scopes</a>.)

  <p>Event handlers must fire first on the <a
   href="#most-derived-binding">most derived binding</a> and then on its
   inherited binding, continuing all the way up the chains to the <a
   href="#base-binding">base binding</a>. A derived handler then has a way of
   preventing the event from flowing to the handlers of the bindings it
   inherits from, by using the <code>stopImmediatePropagation()</code>
   method.

  <div class=example>
   <p>In the following example, the bound element is the <code>hotspot</code>
    element. When either it is clicked or the element inside it is clicked,
    an alert is generated containing the text "Hello World".</p>

   <p>The bound document (here an XML document) is:</p>

   <pre>&lt;hotspot message="Hello World"&gt;
  &lt;instruction&gt; Activate this text. &lt;/instruction&gt;
&lt;/hotspot&gt;</pre>

   <p>The binding is:</p>

   <pre>&lt;binding element="hotspot"&gt;
  &lt;implementation&gt;
    ({ xblBindingAttached: function () {
      this.addEventListener('click', function (event) {
        alert(event.currentTarget.getAttribute('message'));
      }, false);
    }})
  &lt;/implementation&gt;
&lt;/binding&gt;</pre>

   <p>Note that the event object passed to the event handlers on the <a
    href="#internal-object">internal object</a> is the same as would have
    been passed to event handlers registered directly on the bound element.
    This is why <code>currentTarget</code> in this example points to the
    bound element.</p>
  </div>

  <h3 id=event-flow-and-targeting-across-shadow-s><span class=secno>6.2.
   </span><dfn id=event-flow-and-targeting-across-shadow-s0>Event Flow and
   Targeting Across Shadow Scopes</dfn></h3>

  <p>DOM events can fire on shadow targets just as they can on explicit
   targets. Events must flow through the <a
   href="#final-flattened-tree">final flattened tree</a>. As long as the
   event flows within the same shadow tree <a href="#shadow-scope"
   title="shadow scope">scope</a>, it is no different from the behavior
   outlined in the DOM Events specification.

  <p>Whenever events originating from a shadow tree flow from a shadow
   element in that shadow tree to the bound element, one of two actions
   occurs. Either the event is retargeted so that the bound element becomes
   the target, or the event is stopped and flow proceeds to the next phase.
   Whenever an event is retargeted, the event is cloned, with the clone's
   <code>target</code> field set to the bound element.

  <p>The action taken (retarget vs. stop) is specific to the event type. In
   general, UI events must be retargeted and mutation events must be stopped.
   Exceptions to the rule are noted below. The goal of this retargeting or
   stopping is to stop outer shadow scopes from being exposed to nodes from
   inner shadow scopes, and to stop outer shadow scopes from getting
   apparently meaningless events that only make sense in the context of inner
   shadow scopes.

  <p>During the capture phase, the rules are exactly reversed. The first node
   to see the event is the node after which bubbling stops. The target node,
   when the event is passing through a node at a higher shadow scope than the
   event target, is always the bound element in whose shadow content the
   event target lies.

  <p>When an event is retargetted at a bound element, the bound element's
   event handlers must see the event only in the target phase. The capture
   phase listeners must not be triggered for the bound element.

  <p>The timing of event retargeting is such that when the event is forwarded
   to the <a href="#internal-object">internal object</a>, the binding's
   handlers see the relevant shadow tree node as the target, rather than the
   bound element as the target. (See: <a href="#event-forwarding0">event
   forwarding</a>.)

  <p>Events bubble into deeper scopes; for example, an event fired on a bound
   element's <a href="#explicit-children" title="explicit children">explicit
   child</a> bubbles into the element containing the <a
   href="#content"><code>content</code></a> element the element was assigned
   to. This does not cause any event retargeting to take place, either when
   entering the deeper scope or when leaving it, since such an event does not
   actually originate in that shadow tree.

  <p>Any method invocations on any clones of the event object must also be
   forwarded to the original event and all the clones, so that attempts to
   stop propagation and cancel the default action affect the event regardless
   of how many scopes it has crossed.

  <div class=example>
   <p>Bound document:</p>

   <pre>&lt;root xmlns=""&gt;
 &lt;bound/&gt;
&lt;/root&gt;</pre>

   <p>Binding template applied to the <code>bound</code> element:</p>

   <pre>  ...
  &lt;xbl:template&gt;
   &lt;shadow xmlns=""&gt;
    &lt;target/&gt;
   &lt;/shadow&gt;
  &lt;/xbl:template&gt;
  ...</pre>

   <p>If someone clicks the "target" element, the click event is dispatched
    as follows:</p>

   <ol>
    <li>The capture listeners on <code>root</code>. Capture phase, target is
     <code>bound</code>.

    <li>The capture listeners on the binding's <a
     href="#internal-object">internal object</a>. Capture phase, target is
     <code>target</code>.

    <li>The capture listeners on <code>shadow</code>. Capture phase, target
     is <code>target</code>.

    <li>The bubbling listeners on <code>target</code>. Target phase, target
     is <code>target</code>.

    <li>The bubbling listeners on <code>shadow</code>. Bubbling phase, target
     is <code>target</code>.

    <li>The bubbling listeners on the binding's <a
     href="#internal-object">internal object</a>. Bubbling phase, target is
     <code>target</code>.

    <li>The bubbling listeners on <code>bound</code>. Target phase, target is
     <code>bound</code>.

    <li>The bubbling listeners on <code>root</code>. Bubbling phase, target
     is <code>bound</code>.

    <li>The default action listeners on the binding's <a
     href="#internal-object">internal object</a>. Default phase, target is
     <code>target</code>.

    <li>The UA's default action listeners for <code>target</code>. Default
     phase, target is <code>target</code>.
   </ol>
  </div>

  <h3 id=the-default-phase><span class=secno>6.3. </span><dfn
   id=the-default-phase0 title="default phase">The Default Phase</dfn></h3>

  <p>If an event bubbles through or is targeted at one or more bound
   elements, and the event is not canceled (after the capture, target, and
   bubble phases have all completed, its <code>defaultPrevented</code>
   attribute is still false), then the event's <code>eventPhase</code>
   attribute must be set to the value 0x78626C44 <!-- "xblD" in ASCII -->
   (2019716164), and then the event must be <a href="#event-forwarding0"
   title="event forwarding">forwarded</a> to the relevant <a
   href="#internal-object" title="internal object">internal objects</a> of
   all the bound elements the event bubbled through or was targeted at in
   those bubble and target phases, in reverse tree order (starting from the
   target node and walking the tree towards the <code>Document</code> node),
   with <code>currentTarget</code> set to the relevant bound element each
   time. If the event is canceled (that is, if the
   <code>defaultPrevented</code> attribute becomes true) while being
   forwarded to one of these bound elements, subsequent bound elements must
   not receive the event.

  <p>If the event has a UA default action, it must only perform it if the
   <code>defaultPrevented</code> attribute is still false after it has been
   so forwarded.

  <p>The <code>stopPropagation()</code> and
   <code>stopImmediatePropagation()</code> methods must have no effect during
   this "default" phase.

  <h3 id=the-focus-domfocusin-blur-and-domfocusou><span class=secno>6.4.
   </span>The <code>focus</code>, <code>DOMFocusIn</code>, <code>blur</code>,
   and <code>DOMFocusOut</code> Events</h3>

  <p>If shadow content underneath a focusable bound element loses focus and
   shadow content also underneath the bound element takes focus, then both
   focus change events must be stopped. As far as the bound element is
   concerned, it retains focus throughout the two events. (Other
   specifications may go into more detail as to how to determine if an
   element can be focused.)

  <p>If the focus moves from the bound element's shadow content to a node
   completely outside the bound element, or vice versa, then the respective
   events must be retargetted instead.

  <p>The <span>'nav-index'</span> property defined in the CSS UI module <a
   href="#refsCSS3UI">[CSS3UI]</a> can be used to specify the tab order for
   focusable elements. This property can be specified on shadow content. Each
   shadow scope has a unique tab order. The <span>'nav-index'</span> values
   used in one shadow scope are ignored by other shadow scopes. The tab order
   is resolved in the shadow tree first to produce a list of elements in the
   tab order. This list is substituted in place of the bound element in the
   bound element's tree tab order.

  <div class=example>
   <p>As an example, consider the HTML file upload control. It is a focusable
    element that in turn is made up of two focusable shadow elements: a text
    field and a button. Tab indices can be specified on the text field and
    the button to indicate the order in which the components of the file
    control should be accessed when tabbing.</p>

   <p>When the user tabs such that the file control should become focused,
    the user agent determines if any shadow content should also become
    focused, using the tab order specified by the shadow content elements. It
    then generates a focus event on the text field inside the file control.
    As this event flows across shadow scopes, it is retargeted to be a focus
    event on the file control itself.</p>

   <p>Focus events should also be stopped if the bound element is already
    focused. For example, if the user has already focused the text field
    within an HTML file upload control, then the file upload control is now
    also focused. If the user then focuses the button inside the file upload
    control, the focus event generated for the button is stopped before it
    reaches the file control, since the file control is already focused.</p>
  </div>

  <p>Because content in multiple shadow scopes can be focused, the CSS
   <code>:focus</code> pseudo-element is hierarchical in the presence of XBL,
   with up to one element in each shadow scope matching the pseudo-class.
   Style rules can be written with the assumption that they will match (in
   the above example) both the file control and the element focused inside
   the file control. In other words, an arbitrary chain of elements can be in
   the <code>:focus</code> state at the same time.

  <p class=note>Further specifications may describe in more detail the
   interaction of arbitrary chains of elements that can be in the
   <code>:focus</code> state at the same time.

  <h3 id=the-mouseover-and-mouseout-events><span class=secno>6.5. </span>The
   <code>mouseover</code> and <code>mouseout</code> Events</h3>

  <p>Mouseover and mouseout events must be retargeted if the pointing device
   genuinely moves onto (enters) or is moved away (exits) the bound element
   (in addition to entering or exiting some shadow content). If, however, the
   user has simply moved the pointing device from one element in the shadow
   tree to another element in the same shadow tree, without entering or
   exiting the bound element itself, then the event must be stopped.

  <div class=example>
   <p>For example, if the user enters the HTML file upload control from the
    left, a mouseover event is generated for the shadow text field. Because
    this event also constitutes a mouseover of the file control itself, the
    event is retargeted when it flows across shadow scopes. If the user then
    moves the mouse from the text field to the button, a mouseout is
    generated for the text field, followed by a mouseover of the button.</p>

   <p>Since neither of these events constitutes a mouseover or mouseout of
    the file control itself, the events are not allowed to flow to the file
    control. If the user continues moving to the right and leaves the button,
    then the mouseout generated will be retargeted, since the file control
    will also have been exited.</p>
  </div>
<!--
  <h2 id=dom-interfaces><span class=secno>7. </span><dfn
   id=dom-interfaces0>DOM Interfaces</dfn></h2>

  <p>XBL introduces a few XBL-specific interfaces.

  <h3 id=the-documentxbl-interface><span class=secno>7.1. </span>The <a
   href="#documentxbl"><code>DocumentXBL</code></a> Interface</h3>

  <p>The <a href="#documentxbl"><code>DocumentXBL</code></a> interface
   contains methods for loading and obtaining binding documents. The
   interface is implemented by DOM documents that support having their
   elements bound by XBL.

  <dl>
   <dt>IDL Definition

   <dd>
    <pre class=idl>interface <dfn id=documentxbl>DocumentXBL</dfn> {
  readonly attribute NamedNodeMap <a href="#bindingdocuments">bindingDocuments</a>;
  Document <a href="#loadbindingdocument">loadBindingDocument</a>(in DOMString documentURI);
};</pre>

   <dt>Attributes

   <dd>
    <dl>
     <dt><dfn id=bindingdocuments><code
      class=attribute-name>bindingDocuments</code></dfn> of type <code
      class=dom>NamedNodeMap</code>, readonly

     <dd>The <a href="#bindingdocuments"><code>bindingDocuments</code></a>
      attribute must return a <code>NamedNodeMap</code> of all the binding
      documents loaded by the document. Documents are referenced using their
      URIs as the node names, with null namespaces. The
      <code>NamedNodeMap</code> must be live, and must raise
      <code>NO_MODIFICATION_ALLOWED_ERR</code> on any attempts at
      modification or deletion.
    </dl>

   <dt>Methods

   <dd>
    <dl>
     <dt><dfn id=loadbindingdocument><code
      class=method-name>loadBindingDocument</code></dfn>

     <dd>
      <p>The <a
       href="#loadbindingdocument"><code>loadBindingDocument</code></a>
       method must return the <code>Document</code> object corresponding to
       the binding document that has been created for the given URL (creating
       the <code>Document</code> object and kicking off the load if
       necessary). (See: <a
       href="#binding-attachment-and-detachment0">binding attachment and
       detachment</a>.) Any bindings defined by that document must be applied
       to matching elements in the document that corresponds to this <a
       href="#documentxbl"><code>DocumentXBL</code></a> object once the
       document and its subresources are loaded (just before the <code
       title=event-load>load</code> event is fired on the
       <code>Document</code> object).</p>

      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class=parameter-name>documentURI</code> of type <code
          class=dom>DOMString</code>

         <dd>The <a href="#attributes-containing-uris0">URI</a> of a binding
          document.
        </dl>

       <dt>Return Value

       <dd>
        <dl>
         <dt><code>Document</code>

         <dd>The return value of <a
          href="#loadbindingdocument"><code>loadBindingDocument()</code></a>
          is the <code>Document</code> object of the binding document that
          was or will be loaded.
        </dl>

       <dt>No Exceptions
      </dl>
    </dl>
  </dl>

  <h3 id=the-elementxbl-interface><span class=secno>7.2. </span>The <a
   href="#elementxbl"><code>ElementXBL</code></a> Interface</h3>

  <p>The <a href="#elementxbl"><code>ElementXBL</code></a> interface contains
   methods for adding or removing bindings from an element. The interface is
   implemented by all <code>Element</code> nodes (regardless of whether they
   are currently involved with any XBL processing) and may be obtained using
   binding-specific casting methods on an <code>Element</code> interface.

  <dl>
   <dt>IDL Definition

   <dd>
    <pre class=idl>interface <dfn id=elementxbl>ElementXBL</dfn> {
  readonly attribute XBLImplementationList <a href="#xblimplementations">xblImplementations</a>;
  void <a href="#addbinding">addBinding</a>(in DOMString bindingURI);
  void <a href="#removebinding">removeBinding</a>(in DOMString bindingURI);
  boolean <a href="#hasbinding">hasBinding</a>(in DOMString bindingURI);
};</pre>

   <dt>Attributes

   <dd>
    <dl>
     <dt><a href="#xblimplementations"><code>xblImplementations</code></a> of
      type <a
      href="#xblimplementationlist"><code>XBLImplementationList</code></a>,
      readonly

     <dd>See <a href="#binding-implementations0">binding implementations</a>.
    </dl>

   <dt>Methods

   <dd>
    <dl>
     <dt><dfn id=addbinding><code class=method-name>addBinding</code></dfn>

     <dd> The <a href="#addbinding"><code>addBinding</code></a> method must
      attach the specified binding (and any bindings that the binding
      inherits from) to the element. This call is not necessarily
      synchronous. The binding may not be attached yet when the call
      completes.
      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class=parameter-name>bindingURI</code> of type
          <code>DOMString</code>

         <dd>A <a href="#attributes-containing-uris0">URI</a> that specifies
          the location of a specific binding to attach.
        </dl>

       <dt>No Return Value

       <dt>No Exceptions
      </dl>

     <dt><dfn id=removebinding><code
      class=method-name>removeBinding</code></dfn>

     <dd> The <a href="#removebinding"><code>removeBinding</code></a> method
      must detach the specified binding (and any bindings that the binding
      inherits from explicitly using the <code>extends</code> attribute) from
      the element. This method can only detach bindings that were attached
      using <a href="#addbinding"><code>addBinding</code></a>. If the binding
      in question is not attached to this element (or was attached through
      another attachment mechanism) then the method must do nothing.
      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class=parameter-name>bindingURI</code> of type
          <code>DOMString</code>

         <dd>A <a href="#attributes-containing-uris0">URI</a> that specifies
          the location of a specific binding to detach.
        </dl>

       <dt>No Return Value

       <dt>No Exceptions
      </dl>

     <dt><dfn id=hasbinding><code class=method-name>hasBinding</code></dfn>

     <dd>
      <p>The <a href="#hasbinding"><code>hasBinding</code></a> method must
       check the bindings applied to the element and compares each binding's
       URI with the parameter passed. If any of the bindings matches the
       specified URI, then the method must return true, otherwise it must
       return false. This can be used to check if an element has been bound
       to a particular binding in in order to ensure that the expected
       methods and attributes are available.</p>

      <p>Any bindings attached to the element (including, e.g., those
       attached using CSS) are examined by this method.</p>

      <p class=example>For example widgets may walk up their ancestors
       looking for an element that has been bound to a form-container binding
       in order to locate their scope (so that radio buttons may properly be
       mutually exclusive, or so that a submit button can properly submit a
       form).</p>

      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class=parameter-name>bindingURI</code> of type
          <code>DOMString</code>

         <dd>A <a href="#attributes-containing-uris0">URI</a> that specifies
          the location of a specific binding for which to look.
        </dl>

       <dt>Returns

       <dd>
        <dl>
         <dt><code>boolean</code>

         <dd><code>true</code> if any of the bindings match the parameter,
          <code>false</code> otherwise.
        </dl>

       <dt>No Exceptions
      </dl>
    </dl>
  </dl>

  <h4 id=scoping-and-access-using-the-dom><span class=secno>7.2.1.
   </span>Scoping and Access Using the DOM</h4>

  <p>In effect the shadow content exists in its own insulated pocket within
   the document, its <a href="#shadow-scope">shadow scope</a>. Bound elements
   have no knowledge of their shadow children in terms of DOM Core <a
   href="#refsDOM3CORE">[DOM3CORE]</a>. The shadow content is not accessible
   via the <code>childNodes</code> list for the bound element, nor is it
   accessible using <code>firstChild</code>/<code>nextSibling</code> to
   iterate over the children of the bound element.

  <p>DOM methods that can be invoked on elements (e.g.,
   <code>getElementsByTagName()</code>) will only see nodes that are in the
   same shadow scope. Methods invoked on the document (e.g., <code
   title="">getElementById</code>) only see nodes that are not in shadow
   trees.

  <p>On shadow content nodes, <code>ownerDocument</code> always points to the
   document from which the nodes were cloned.

  <p>Elements in different shadow scopes may have clashing IDs. IDs need only
   be unique within each shadow scope.

  <p>Elements that are the root of a shadow tree (the cloned <a
   href="#template"><code>template</code></a> elements) cannot be inserted
   into a document. Any attempt to do so must raise a
   <code>HIERARCHY_REQUEST_ERR</code>. --><!-- (This is because if you
  did, you would end up having two ways to reach the nodes in the
  <span>final flattened tree</span>, which would be mighty confusing
  for things like getComputedStyle() --><!--

  <p>Manipulating the DOM of a shadow tree (<a
   href="#content"><code>content</code></a> elements being moved about or
   even removed altogether, <a href="#attributes4"><code
   title=attr-attributes>attributes</code></a> attributes being attached and
   modified, etc) must immediately cause the <a
   href="#final-flattened-tree">final flattened tree</a> to be updated.

  <p>Because each bound element gets its own copy of the cloned template,
   changes to a bound element's shadow content only affect that bound
   element. Other bindings are unaffected.

  <p>If an element is added to the DOM dynamically, its shadow scope is that
   of its parent element. Adding an element as a child of a bound element
   causes that element to be assigned to an appropriate <a
   href="#content"><code>content</code></a> element (if there is one &mdash;
   if there is not, the element does not appear anywhere in the <a
   href="#final-flattened-tree">final flattened tree</a>).

  <h3 id=the-xblcontentelement-interface><span class=secno>7.3. </span>The <a
   href="#xblcontentelement"><code>XBLContentElement</code></a> Interface</h3>

  <p>The <a href="#xblcontentelement"><code>XBLContentElement</code></a>
   interface is implemented by <a href="#content"><code>content</code></a>
   elements in the XBL namespace (regardless of whether they are <a
   href="#in-error">in error</a> or not).

  <dl>
   <dt>IDL Definition

   <dd>
    <pre
     class=idl>interface <dfn id=xblcontentelement>XBLContentElement</dfn> : Element {
  readonly attribute <span>NodeList</span> <a href="#xblchildnodes">xblChildNodes</a>;
  void <a href="#setinsertionpoint">setInsertionPoint</a>(in Node child);
};</pre>

   <dt>Attributes

   <dd>
    <dl>
     <dt><dfn id=xblchildnodes><code>xblChildNodes</code></dfn> of type
      <code>NodeList</code>, readonly

     <dd>
      <p>The <a href="#xblchildnodes"><code>xblChildNodes</code></a>
       attribute must return a <code>NodeList</code> containing a live list
       of all the nodes that are currently assigned to the <a
       href="#content"><code>content</code></a> element.</p>

      <p class=note>A node can be assigned to multiple <a
       href="#content"><code>content</code></a> elements simultaneously, in
       the case of bound elements inside shadow trees.</p>

      <p>Exception: if the <a href="#content"><code>content</code></a>
       element is not in a <a href="#shadow-tree">shadow tree</a>, then this
       attribute must return null.</p>
    </dl>

   <dt>Methods

   <dd>
    <dl>
     <dt><dfn id=setinsertionpoint><code>setInsertionPoint</code></dfn>

     <dd>
      <p>The <a href="#setinsertionpoint"><code>setInsertionPoint</code></a>
       method perform the following steps.</p>

      <ol>
       <li>Let <var title="">e</var> be the bound element for which the user
        agent generated the shadow tree in which the given <a
        href="#content"><code>content</code></a> element finds itself. If
        there is no such bound element (e.g. the <a
        href="#content"><code>content</code></a> element has been removed
        from its shadow tree), then the method must raise an
        <code>INVALID_STATE_ERR</code> exception.

       <li>Let <var title="">child</var> be the node that was given as an
        argument to the method.

       <li>The user agent must then check that the parent of <var
        title="">child</var> is in fact <var title="">e</var>. If it is not,
        then the method must raise an <code>HIERARCHY_REQUEST_ERR</code>
        exception.

       <li>The user agent must then check that either the <a
        href="#content"><code>content</code></a> element has no <a
        href="#includes"><code
        title=attr-content-includes>includes</code></a> attribute, or that
        <var title="">child</var> matches the selector given in the <a
        href="#content"><code>content</code></a> element's <a
        href="#includes"><code
        title=attr-content-includes>includes</code></a> attribute. If the
        attribute is present but the element does not match the selector it
        specifies (or if the selector is not syntactically correct), then the
        method must raise an <code>TYPE_MISMATCH_ERR</code> exception.</li>
       --><!-- XXX
           that one is stretching it --><!--

       <li>Finally, the user agent must assign <var title="">child</var> to
        the <a href="#content"><code>content</code></a> element, instead of
        whatever previous <a href="#content"><code>content</code></a> element
        it was assigned to, if any.
      </ol>

      <p>If a node is assigned, using the <a
       href="#setinsertionpoint"><code>setInsertionPoint</code></a> method,
       to a <a href="#content"><code>content</code></a> element that is not
       locked, then the element will only remain there until such time as the
       user agent redistributes the bound element's explicit children.</p>

      <p>See <a href="#processing-content-elements0">processing
       <code>content</code> elements</a>.</p>

      <p class=note>The order of nodes assigned to a <a
       href="#content"><code>content</code></a> element is always be the same
       as the relative order of those nodes in the original core DOM.</p>

      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class=parameter-name>child</code> of type
          <code>Node</code>

         <dd>The child of the bound element to assign to this <a
          href="#content"><code>content</code></a> element.
        </dl>

       <dt>No Return Value

       <dt>No Exceptions
      </dl>

      <div class=example>
       <p>The following example implements a tabbed interface as a binding.
        It creates a list of buttons to enable the user to access each of the
        sections that the tab box contains, and then uses <a
        href="#setinsertionpoint"><code>setInsertionPoint()</code></a> to
        make the selected tab panel appear.</p>

       <pre>
&lt;binding>
 &lt;template>
  &lt;style scoped>
   #tabs > div { /* style for tabs */ }
   #tabs > div.selected { /* style for selected tab */ }
   .panel { /* style for panel */ }
   .hidden { display: none; }
  &lt;/style>
  &lt;div id="tabs"/>
  &lt;div class="panel">&lt;content id="current" locked="true"/>&lt;/div>
  &lt;div class="hidden">&lt;content id="not-current"/>&lt;/div>
 &lt;/template>
 &lt;implementation>
  ({
    set current(section) {
      if (this._current)
        this.shadowTree.getElementById('not-current').setInsertionPoint(this._current);
      this._current = section;
      if (this._current)
        this.shadowTree.getElementById('current').setInsertionPoint(this._current);
    },
    get current() {
      return this._current;
    },
    xblBindingAttached: function() {
      this.updateTabs();
      this.current = this.boundElement.getElementsByTagName('section')[0];
    },
    clearTabs: function() {
      with (this.shadowTree.getElementById('tabs'))
        while (hasChildNodes())
          removeChild(firstChild);
    },
    addTabFor: function(section) {
      var tab = document.createElement('div');
      tab.appendChild(document.createTextNode(section.getAttribute('title')););
      tab.addEventListener('click', function (_this) { return function (event) {
        var tabs = this.shadowTree.getElementByID('tabs').getElementsByTagName('div');
        for (var i = 0; i &amp;lt; tabs.length; ++i)
          tabs[i].setAttribute('class', '');
        _this.current = section;
        event.target.setAttribute('class', 'selected');
        event.preventDefault();
      } }(this), false);
      this.shadowTree.getElementById('tabs').appendChild(tab);
    },
    updateTabs: function() {
      this.clearTabs();
      var sections = this.boundElement.getElementsByTagName('section');
      for (var i = 0; i &amp;lt; sections.length; ++i)
        this.addTabFor(sections[i]);
    },
  })
 &lt;/implementation>
&lt;/binding></pre>

       <p>This binding could be applied to any element that has
        <code>section</code> elements as children, each <code>section</code>
        element having its title given in its <code>title</code> attribute.</p>

       <p>The binding implemented above doesn't dynamically update when the
        DOM is changed, a full implementation would probably want to listen
        to mutation events to catch attribute changes and insertions and
        removals of the panels.</p>
       --><!-- XXX it also doesn't remove event listeners when the
           tabs are removed --><!--
       </div>
    </dl>
  </dl>

  <h3 id=the-htmltemplateelement-interface><span class=secno>7.4. </span>The
   <a href="#htmltemplateelement"><code>HTMLTemplateElement</code></a>
   Interface</h3>

  <p>The <a href="#htmltemplateelement"><code>HTMLTemplateElement</code></a>
   interface is implemented by <a href="#template"><code>template</code></a>
   elements that are in the XBL namespace (regardless of whether they are <a
   href="#in-error">in error</a> or not).

  <dl>
   <dt>IDL Definition

   <dd>
    <pre class=idl>
interface <dfn id=htmltemplateelement>HTMLTemplateElement</dfn> : HTMLElement {
  Element <a href="#getelementbyid">getElementById</a>(in DOMString elementId);
};
</pre>

   <dt>Attributes

   <dd>No Attributes

   <dt>Methods

   <dd>
    <dl>
     <dt><dfn class=method-name
      id=getelementbyid><code>getElementById</code></dfn>

     <dd>
      <p class=note>This method is modeled after the method of the same name
       defined by <a href="#refsDOM3CORE">[DOM3CORE]</a> on the
       <code>Document</code> interface.</p>

      <p>This method must return an <code>Element</code> that has an ID
       attribute with the given value, and that is a descendant of the <a
       href="#template"><code>template</code></a> element on which it is
       invoked. If more than one such element exists, which one is returned
       is undefined. If no such element exists, this returns
       <code>null</code>.</p>

      <p class=note>Attributes with the name "ID" or "id" are not of type ID
       unless so defined. For example, attributes with the name "id" on
       elements that are from the XHTML, MathML and XBL namespaces are
       defined to be of type ID by their respective specifications.</p>

      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class=parameter-name>elementId</code> of type
          <code>DOMString</code>

         <dd>The unique <code>id</code> value for an element.
        </dl>

       <dt>Returns

       <dd>
        <dl>
         <dt><code>Element</code>

         <dd> The matching element or null if there is none.
        </dl>

       <dt>No Exceptions
      </dl>
    </dl>
  </dl>

  <h3 id=the-htmlbindingelement-interface><span class=secno>7.5. </span>The
   <a href="#htmlbindingelement"><code>HTMLBindingElement</code></a>
   Interface</h3>

  <p>XBL <a href="#binding0"><code>binding</code></a> elements must implement
   the following interface:

  <pre
   class=idl>[NamedConstructor=<a href="#bindingselector" title=dom-binding>Binding</a>(in optional DOMString selector)]
interface <dfn id=htmlbindingelement>HTMLBindingElement</dfn> : <span>HTMLElement</span> {
  <a href="#htmltemplateelement">HTMLTemplateElement</a> <a href="#gettemplate" title=dom-binding-getTemplate>getTemplate</a>();
  void <a href="#setimplementationimplementationprototype" title=dom-binding-setImplementation>setImplementation</a>(in Object implementationPrototypeObject);
  void <a href="#addtodocument" title=dom-binding-addToDocument>addToDocument</a>();
};</pre>

  <p>The <dfn id=bindingselector title=dom-binding><code>Binding(<var
   title="">selector</var>)</code></dfn> constructor must create a <a
   href="#binding0"><code>binding</code></a> element. If there is an
   argument, then the element's <a href="#element"><code
   title=attr-binding-element>element</code></a> attribute must be set to
   that argument's value.

  <p>The <dfn id=gettemplate
   title=dom-binding-getTemplate><code>getTemplate</code></dfn> method must
   first check to see if the <a href="#binding0"><code>binding</code></a>
   element has a <a href="#template"><code>template</code></a> element child;
   if it does not, then one must be created and appended as a child of the
   element. Then, the method must return the first <a
   href="#template"><code>template</code></a> element child of the <a
   href="#binding0"><code>binding</code></a> element.

  <p>The <dfn id=setimplementationimplementationprototype
   title=dom-binding-setImplementation><code>setImplementation(<var
   title="">implementationPrototypeObject</var>)</code></dfn> method must
   first check to see if the element has an <i>implementation prototype
   object</i> set. If it does (even if it is null), then the method must
   raise an <code>INVALID_STATE_ERR</code> exception. Otherwise, it must set
   the element's <i>implementation prototype object</i>'s to <var
   title="">implementationPrototypeObject</var>.

  <p>The <dfn id=addtodocument
   title=dom-binding-addToDocument><code>addToDocument()</code></dfn> method
   must append the element to the first <code>head</code> element in the
   document, if any, or else the element's root element, if any, or else the
   <code>Document</code> object itself (as the root element).

  <div class=example>
   <p>This interface lets you implement a binding purely from script:</p>

   <pre>var fancyHeader = new Binding('h1');
fancyHeader.getTemplate().innerHTML = '&#x263A; &lt;content>&lt;/content> &#x263A;';
fancyHeader.setImplementation({
  xblBindingAttached: function () {
    this.addEventListener('click', this.clicked, false);
  },
  clicked: function(event) {
    alert('Hello!');
  },
});
fancyHeader.addToDocument();</pre>

   <p>This would be equivalent to the following markup:</p>

   <pre>&lt;binding element="h1">
 &lt;template>&#x263A; &lt;content>&lt;/content> &#x263A;&lt;/template>
 &lt;implementation>
  ({
    xblBindingAttached: function () {
      this.addEventListener('click', this.clicked, false);
    },
    clicked: function(event) {
      alert('Hello!');
    },
  })
 &lt;/implementation>
&lt;/binding></pre>
  </div>

  <h3 id=the-eventxbl-interface><span class=secno>7.6. </span>The <a
   href="#eventxbl"><code>EventXBL</code></a> Interface</h3>

  <p>Objects that implement the <code>Event</code> interface must also
   implement the <a href="#eventxbl"><code>EventXBL</code></a> interface. <a
   href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  <dl>
   <dt>IDL Definition

   <dd>
    <pre class=idl>interface <dfn id=eventxbl>EventXBL</dfn> {
  readonly attribute boolean <a href="#trusted" title=event-trusted>trusted</a>;
};</pre>
  </dl>

  <p>The <dfn id=trusted title=event-trusted><code>trusted</code></dfn>
   attribute must return true if the user agent dispatched the event (e.g. in
   response to user action), and false otherwise (e.g. if an author script
   dispatched a synthetic event). Events fired by the user agent in response
   to untrusted events must themselves be untrusted.</p>
  --><!--XXX
  <h2>Widget Bindings</h2>

  <p class="big-issue">(to be completed)</p>

  <p>A <dfn>widget binding</dfn> is a binding that extends either
  the <span class= "css">widget</span> base binding or any of the
  other <dfn>predefined base bindings</dfn> for widgets listed
  below.</p>

  <h3 id="base-bindings">Predefined Base Bindings</h3>

  <p>The following bindings have predefined meaning.</p>

  <dl>

   <dt>widget</dt>

   <dd>Implements the <code>value</code> property.</dd>

   <dt>native-checkbox</dt>

   <dd>...</dd>

   <dt>simple-checkbox</dt>

   <dd>...</dd>

   <dt>widget-scope</dt>

   <dd>Implements the <code>submit</code> and <code>reset</code>
   methods.</dd>

  </dl>
--><!--

  <h2 id=resources><span class=secno>8. </span>Resources</h2>

  <h3 id=loading-external-resources><span class=secno>8.1. </span><dfn
   id=loading-external-resources0>Loading External Resources</dfn></h3>

  <h4 id=binding-documents><span class=secno>8.1.1. </span>Binding Documents</h4>

  <p>Several features in XBL allow binding documents to be loaded.

  <p>When the specification says that a binding document must be loaded
   <em>unless it has already been loaded</em>, then references to the same
   binding document (even if they are somewhat indirect, for example via HTTP
   redirects) must result in the same <code>Document</code> instance being
   reused, or shared.

  <p>To determine if two binding documents are the same, their final base
   URIs (after all redirects) are compared.

  <div class=example>
   <p>A <a href="#binding-document">binding document</a> A contains a <a
    href="#binding0"><code>binding</code></a> element that refers to a second
    binding document X. A new DOM <code>Document</code> instance is created
    to represent that instance and the relevant bindings are used.</p>

   <p>Now assume RX is a resource that redirects to resource X using the HTTP
    301 redirection mechanism. A second <a
    href="#binding0"><code>binding</code></a> element in the binding document
    A refers to resource RX. When that resource is being loaded, the redirect
    to X would be discovered, and therefore instead of creating a new
    <code>Document</code>, the existing one is reused.</p>
  </div>

  <p>Such sharing of binding documents must be limited to binding documents
   loaded by a document, its binding documents, its scripts, and its style
   sheets. Nested documents and images do not share binding documents with
   each other or with their container document.

  <div class=example>
   <p>For example, if a document uses a binding document, and its style
    sheets use that binding document, the same binding document instance will
    be used for both cases. However, if that document contains an
    <code>iframe</code> whose document uses the same binding document, a new
    instance will be used: the binding document instance from the outer
    document is not reused.</p>
  </div>

  <p>Binding documents that are currently loading count as binding documents
   that are already loaded for the purposes of this reuse mechanism.

  <p>References to binding documents that have another origin than the
   aspiring bound document must be treated as being <a href="#in-error">in
   error</a>, failing as if it was not available.</p>
  --><!-- CORS goes here --><!--

  <h4 id=external-resources><span class=secno>8.1.2. </span>External
   Resources</h4>

  <p>When the specification simply says that the external resource must be
   loaded, without giving any caveats regarding multiple accesses of the same
   resource, then each reference must instantiate a new unique copy of the
   document.

  <p class=example>For example, two <code>style</code> elements whose
   <code>src</code> attributes point to the same style sheet must create two
   different <code>Stylesheet</code> instances, such that mutating one does
   not affect the other.

  <p>Several XBL attributes are defined to contain URIs. All URIs may be
   relative. For relative URIs, the rules given in <a
   href="#refsXMLBASE">[XMLBASE]</a> must be used to resolve the value to an
   absolute URI.

  <h3 id=loading-and-running-scripts><span class=secno>8.2. </span><dfn
   id=loading-and-running-scripts0>Loading and Running Scripts</dfn></h3>

  <p>Scripts in XBL may be found in <a
   href="#implementation"><code>implementation</code></a> elements, or in
   resources that such elements point to.

  <p>For <a href="#src"><code
   title=attr-implementation-src>implementation</code></a> elements, if a
   <code title="">src</code> attribute is present then the contents of the
   element must be <span title="">ignored</span> (even if fetching the
   specified URI fails).

  <p>If the content is inline, UAs must concatenate all the textual contents
   of text and CDATA child nodes, and must <a href="#ignoring">ignore</a> any
   other, non-text nodes (such as elements and comments) along with all their
   children. All descendant elements must be processed, though, according to
   their semantics, before the XBL script block itself is executed.

  <p>If the content is not inline, then when the element is evaluated, the
   resource specified by the <code title="">src</code> attribute must be
   fetched. For <a href="#implementation"><code>implementation</code></a>
   elements, while the external script is being fetched, the <a
   href="#binding-attachment-model0" title="Binding Attachment
   Model">attachment</a> of that binding must block. The contents of that
   file must be used directly, as specified by the ECMAScript language
   specification.

  <h4 id=scripting><span class=secno>8.2.1. </span>Scripting Model</h4>
  --><!-- this needs updating to match reality --><!--

  <p>Each document that runs script (including bound documents and binding
   documents) has a <code>DocumentWindow</code> object, a <code>Window</code>
   object, a global script scope, and a security context. In ECMAScript, the
   global script scope and the <code>Window</code> object are one and the
   same.

  <p>Script must always be executed in the context of the global script scope
   of the document specified by the script's element's
   <code>ownerDocument</code> DOM attribute. This implies that scripts from
   different bindings in the same binding document bound to different
   elements in the same bound document share the same scripting scope. If the
   bindings were defined in the document itself, then the scope is the same
   scope as for that document.

  <p>A binding document must inherit the security context of the document to
   which it is bound, not the security context of the domain from which it
   was fetched.

  <p>In binding documents, the <code>location</code> and <code>history</code>
   properties of the <code>Window</code> object, and the
   <code>location</code> and <code>cookie</code> properties of the
   <code>DocumentWindow</code> object, must return null, and any methods that
   are defined in terms of the browsing context's session history must do
   nothing. <a href="#refsHTML5">[HTML5]</a></p>
  --><!-- CORS goes here too --><!--

  <h3 id=interpretation-of-uris-to-xbl-bindings><span class=secno>8.3.
   </span><dfn id=interpretation-of-uris-to-xbl-bindings0>Interpretation of
   URIs to XBL bindings</dfn></h3>

  <p>XBL attachment mechanisms use a URI to specify which binding to attach
   to the designated element.

  <div class=example>
   <p>For example:</p>

   <pre>my|foo {
   binding: url("<strong>http://www.example.org/bindings.xml#fooBinding</strong>");
}</pre>
  </div>

  <p>This section defines how these URIs, which are used in the argument to
   the <a href="#addbinding"><code>addBinding()</code></a> method, and in the
   value of the '<a href="#binding1"><code title="binding
   property">binding</code></a>' property, are to be interpreted.

  <p>The URI specifies a particular HTML or XML document. The user agent must
   fetch this resource (unless it has <a href="#loading-external-resources0"
   title="loading external resources">already been loaded</a>).

  <p>If the URI contains a fragment identifier, then it must be processed as
   described in the relevant MIME type definition. The element targeted by
   the fragment identifier must be a <a
   href="#binding0"><code>binding</code></a> element in the specified
   document, otherwise the URI is <a href="#in-error">in error</a>.

  <p class=example>For example, if the binding document is sent as
   <code>application/xhtml+xml</code>, and the fragment identifier matches a
   <a href="#binding0"><code>binding</code></a> element's <code
   title=attr-id>id</code> attribute, then that is the binding that is
   attached.

  <p>If there is no fragment identifier, the URI does not point to a <a
   href="#correct">correct</a> binding and is <a href="#in-error">in
   error</a>.

  <p>When an attachment mechanism uses a URI that is <a href="#in-error">in
   error</a> (as per the last two paragraphs), then the user agent must act
   as if the attachment mechanism had not specified that binding.

  <p>Otherwise, the specified binding is attached to the element, as
   described for the relevant attachment mechanism.

  <h2 id=summaries><span class=secno>9. </span>Summaries of Elements,
   Attributes, and Events</h2>

  <h3 id=elements-and-attributes><span class=secno>9.1. </span>Elements and
   Attributes</h3>

  <p><em>This section is non-normative.</em>

  <table>
   <thead>
    <tr>
     <th>Element

     <th>Attributes

     <th>Content Model

   <tbody>
    <tr>
     <td><a href="#binding0"><code>binding</code></a>

     <td>
      <ul>
       <li>Global attributes

       <li><a href="#extends"><code
        title=attr-binding-extends>extends</code></a>

       <li><a href="#element"><code
        title=attr-binding-element>element</code></a>
      </ul>

     <td>
      <ul>
       <li><a href="#implementation"><code>implementation</code></a>

       <li><a href="#template"><code>template</code></a>
      </ul>

    <tr>
     <td><a href="#implementation"><code>implementation</code></a>

     <td>
      <ul>
       <li>Global attributes

       <li><a href="#src"><code title=attr-implementation-src>src</code></a>
      </ul>

     <td>
      <ul>
       <li>Script
      </ul>

    <tr>
     <td><a href="#template"><code>template</code></a>

     <td>
      <ul>
       <li>Global attributes

       <li><a href="#apply-author-sheets"><code
        title=attr-template-apply-author-sheets>apply-author-sheets</code></a>
        

       <li><a href="#allow-selectors-through"><code
        title=attr-template-allow-selectors-through>allow-selectors-through</code></a>
        
      </ul>

     <td>
      <ul>
       <li><a href="#content"><code>content</code></a>

       <li><a href="#inherited"><code>inherited</code></a>

       <li>Non-XBL elements, optionally with <a href="#attributes4"><code
        title=attr-attributes>attributes</code></a> and <a
        href="#pseudo"><code title=attr-pseudo>pseudo</code></a> attributes
      </ul>

    <tr>
     <td><a href="#content"><code>content</code></a>

     <td>
      <ul>
       <li>Global attributes

       <li><a href="#includes"><code
        title=attr-content-includes>includes</code></a>

       <li><a href="#apply-binding-sheets"><code
        title=attr-content-apply-binding-sheets>apply-author-sheets</code></a>
        

       <li><a href="#locked"><code
        title=attr-content-locked>locked</code></a>
      </ul>

     <td>
      <ul>
       <li><a href="#inherited"><code>inherited</code></a>

       <li>Non-XBL elements, optionally with <a href="#attributes4"><code
        title=attr-attributes>attributes</code></a> and <a
        href="#pseudo"><code title=attr-pseudo>pseudo</code></a> attributes
      </ul>

    <tr>
     <td><a href="#inherited"><code>inherited</code></a>

     <td>
      <ul>
       <li>Global attributes
      </ul>

     <td>
      <ul>
       <li><a href="#content"><code>content</code></a>

       <li>Non-XBL elements, optionally with <a href="#attributes4"><code
        title=attr-attributes>attributes</code></a> and <a
        href="#pseudo"><code title=attr-pseudo>pseudo</code></a> attributes
      </ul>
  </table>

  <h3 id=events><span class=secno>9.2. </span>Events</h3>

  <p><em>This section is non-normative.</em>

  <table>
   <thead>
    <tr>
     <th>Event Name

     <th>Interface

     <th>Target when fired by UA

     <th>Bubbles?

     <th>Cancelable?

     <th>Default Action

   <tbody>
    <tr>
     <td><a href="#xbl-bound"><code title=xbl-bound>xbl-bound</code></a>

     <td><code>Event</code>

     <td>Bound element

     <td>&#x2713; Bubbles

     <td>&mdash;

     <td>None

    <tr>
     <td><a href="#xbl-bindings-are-ready"><code
      title=xbl-bindings-are-ready>xbl-bindings-are-ready</code></a>

     <td><code>Event</code>

     <td>Bound document's root element

     <td>&#x2713; Bubbles

     <td>&mdash;

     <td>None
  </table>

  <h3 id=implementations><span class=secno>9.3. </span>Implementations</h3>

  <p><em>This section is non-normative.</em>

  <p>The properties of the <a href="#internal-object">internal object</a>
   are:

  <ul class=brief>
   <li><a href="#external"><code>external</code></a>

   <li><a href="#boundelement"><code>boundElement</code></a>

   <li><a href="#shadowtree"><code>shadowTree</code></a>

   <li><a href="#basebinding"><code>baseBinding</code></a>

   <li>the members of the <code>EventTarget</code> interface
  </ul>

  <p>The methods that binding implementations can support are:

  <ul class=brief>
   <li><a href="#xblbindingattached"><code>xblBindingAttached()</code></a>

   <li><a href="#xblentereddocument"><code>xblEnteredDocument()</code></a>

   <li><a href="#xblleftdocument"><code>xblLeftDocument()</code></a>
  </ul>

  <h2 class=no-num id=acknowledgments>Acknowledgments</h2>

  <p>David Hyatt developed XBL 1.0 and provided guidance for the development
   of XBL 2.0.

  <p>The editor would like to thank Alex Danilo, Alex Russell, Alex Vincent,
   Anne van Kesteren, Axel Hecht, Antoine Quint, Benjamin Smedberg, Bjoern
   Hoehrmann, Boris Zbarsky, Brendan Eich, Cameron McCormack, Chris Lilley,
   Christophe Jolif, Cyril Concolato, Darryl Fuller, David
   H&aring;s&auml;ther, Dean Jackson, Dimitri Glazkov, Jon Ferraiolo, Jonas
   Sicking, Karl Dubost, L. David Baron, Lachlan Hunt, Liam Quin, Maciej
   Stachowiak, Marcos Caceres, Mark Baker, Micah Dubinko, Mihai Sucan, Mikko
   Pohja, Mohamed Zergaoui, Norman Walsh, Peter Sorotokin, Robin Berjon, Ruud
   Steltenpool, Sam Weinig, Sean Hogan, Simon Pieters, Steve K. Speicher,
   Steve Zilles, Tab Atkins, Tim Rowley, and Tom Pike for their contributions
   to this specification.

  <h2 class=no-num id=references>References</h2>

  <p>All references are normative unless prefixed by the mark
   "(Informative)".

  <dl>
   <dt id=refsCSS21>[CSS21]

   <dd><cite><a href="http://www.w3.org/TR/2004/CR-CSS21-20040225/">CSS 2.1
    Specification</a></cite>, B. Bos, T. &Ccedil;elik, I. Hickson, H. Lie.
    W3C, September 2003. The latest version of the CSS 2.1 specification is
    available at <a
    href="http://www.w3.org/TR/CSS21/">http://www.w3.org/TR/CSS21/</a>

   <dt id=refsCSS3UI>[CSS3UI]

   <dd><cite><a href="http://www.w3.org/TR/2004/CR-css3-ui-20040511/">CSS3
    Basic User Interface Module</a></cite>, T. &Ccedil;elik. W3C, May 2004.
    The latest version of the CSS3 UI module is available at <a
    href="http://www.w3.org/TR/css3-ui/">http://www.w3.org/TR/css3-ui/</a>

   <dt id=refsDOM3CORE>[DOM3CORE]

   <dd><cite><a
    href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/">Document
    Object Model (DOM) Level 3 Core Specification</a></cite>, A. Le Hors, P.
    Le H&eacute;garet, L. Wood, G. Nicol, J. Robie, M. Champion, S. Byrne.
    W3C, November 2003. The latest version of the DOM Level 3 Core
    specification is available at <a
    href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>

   <dt id=refsDOM3EVENTS>[DOM3EVENTS]

   <dd><cite><a
    href="http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/">Document
    Object Model (DOM) Level 3 Events Specification</a></cite>, P. Le
    H&eacute;garet, T. Pixley. W3C, November 2003. (Note: Despite its
    non-normative status on the W3C Recommendation track, this specification
    should be considered normative for the purposes of conformance.) The
    latest version of the DOM Level 3 Events specification is available at <a
    href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>

   <dt id=refsECMA262>[ECMA262]

   <dd><cite><a
    href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript
    Language Specification</a></cite>, Third Edition. ECMA, December 1999.
    This version of the ECMAScript Language is available at
    http://www.ecma-international.org/publications/standards/Ecma-262.htm

   <dd>(Informative) <cite><a
    href="http://developer.mozilla.org/es4/spec/spec.html">ECMAScript
    Language Specification</a></cite>, Fourth Edition (Incomplete Draft
    Proposal). ECMA, January 2006. This version of the ECMAScript Language is
    available at http://developer.mozilla.org/es4/spec/spec.html

   <dt id=refsHTC>[HTC]

   <dd>(Informative) <cite><a
    href="http://www.w3.org/TR/1998/NOTE-HTMLComponents-19981023">HTML
    Components</a></cite>, C. Wilson. Microsoft, September 1998. The HTML
    Components submission is available at
    http://www.w3.org/TR/1998/NOTE-HTMLComponents-19981023

   <dt id=refsHTML5>[HTML5]

   <dd>(Informative) <cite><a
    href="http://whatwg.org/specs/web-apps/current-work/">Web Applications
    1.0</a></cite>, I. Hickson. WHATWG, work in progress. The latest version
    of the HTML5 proposal is at
    http://whatwg.org/specs/web-apps/current-work/

   <dt id=refsMQ>[MQ]

   <dd><cite><a
    href="http://www.w3.org/TR/2002/CR-css3-mediaqueries-20020708/">Media
    Queries</a></cite>, H. Lie, T. &Ccedil;elik, D Glazman. W3C, July 2002.
    The latest version of Media Queries is available at <a
    href="http://www.w3.org/TR/css3-mediaqueries/">http://www.w3.org/TR/css3-mediaqueries/</a>

   <dt id=refsRFC2045>[RFC2045]

   <dd><cite><a href="http://www.ietf.org/rfc/rfc2045">Multipurpose Internet
    Mail Extensions (MIME) Part One: Format of Internet Message
    Bodies</a></cite>, N. Freed, N. Borenstein. IETF, November 1996. RFC 2045
    is available at http://www.ietf.org/rfc/rfc2045

   <dt id=refsRFC2119>[RFC2119]

   <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">Key words for use
    in RFCs to Indicate Requirement Levels</a></cite>, S. Bradner. IETF,
    March 1997. RFC 2119 is available at http://www.ietf.org/rfc/rfc2119.txt

   <dt id=refsRFC3986>[RFC3986]

   <dd><cite><a href="http://www.ietf.org/rfc/rfc3986">Uniform Resource
    Identifier (URI): Generic Syntax</a></cite>, T. Berners-Lee, R. Fielding,
    L. Masinter. IETF, January 2005. RFC 3986 is available at
    http://www.ietf.org/rfc/rfc3986

   <dt id=refsRFC3987>[RFC3987]

   <dd><cite><a href="http://www.ietf.org/rfc/rfc3987">Internationalized
    Resource Identifiers (IRIs)</a></cite>, M. D&uuml;rst, M. Suignard. IETF,
    January 2005. RFC 3987 is available at http://www.ietf.org/rfc/rfc3987

   <dt id=refsSELECTORS>[SELECTORS]

   <dd><cite><a
    href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113/">Selectors</a></cite>,
    D. Glazman, T. &Ccedil;elik, I. Hickson. W3C, November 2001. The latest
    version of the Selectors specification is available at <a
    href="http://www.w3.org/TR/css3-selectors/">http://www.w3.org/TR/css3-selectors/</a>

   <dt id=refsUNICODE>[UNICODE]

   <dd><cite><a href="http://www.unicode.org/versions/Unicode5.0.0/">The
    Unicode Standard, Version 5.0.0</a></cite>, The Unicode Consortium.
    Boston, MA, Addison-Wesley, November 2006. ISBN
    0-321-48091-0--><!--, as amended by <a href="http://www.unicode.org/versions/Unicode5.0.1/">Unicode 5.0.1</a> and <a href="http://www.unicode.org/versions/Unicode5.1.0/">Unicode 5.1.0</a>--><!--.
    The latest version of the Unicode specification is available at <a
    href="http://www.unicode.org/versions/">http://www.unicode.org/versions/</a>

   <dt id=refsXBL10>[XBL10]

   <dd>(Informative) <cite><a
    href="http://www.w3.org/TR/2001/NOTE-xbl-20010223/">XML Binding
    Language</a></cite>, D. Hyatt. Mozilla, February 2001. The XBL submission
    is available at http://www.w3.org/TR/2001/NOTE-xbl-20010223/

   <dd>(Informative) <cite><a
    href="http://www.mozilla.org/projects/xbl/xbl.html">XML Binding
    Language</a></cite>, D. Hyatt. Mozilla, November 2000 (and subsequently
    edited by other contributors). The XBL 1.0 specification is available at
    http://www.mozilla.org/projects/xbl/xbl.html

   <dt id=refsXML>[XML]

   <dd><cite><a href="http://www.w3.org/TR/2006/REC-xml-20060816/">Extensible
    Markup Language (XML) 1.0 (Fourth Edition)</a></cite>, T. Bray, J. Paoli,
    C. Sperberg-McQueen, E. Maler, F. Yergeau. W3C, September 2006. The
    latest version of the XML specification is available at <a
    href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>

   <dt id=refsXMLBASE>[XMLBASE]

   <dd><cite><a href="http://www.w3.org/TR/2001/REC-xmlbase-20010627/">XML
    Base</a></cite>, J. Marsh. W3C, June 2001. The latest version of the XML
    Base specification is available at <a
    href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>

   <dt id=refsXMLNS>[XMLNS]

   <dd><cite><a
    href="http://www.w3.org/TR/2006/REC-xml-names-20060816/">Namespaces in
    XML (Second Edition)</a></cite>, T. Bray, D. Hollander, A. Layman, R.
    Tobin. W3C, August 2006. The latest version of the Namespaces in XML
    specification is available at <a
    href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a>

   <dt id=refsXMLSSPI>[XMLSSPI]

   <dd><cite><a
    href="http://www.w3.org/1999/06/REC-xml-stylesheet-19990629/">Associating
    Style Sheets with XML documents</a></cite>, J. Clark. W3C, June 1999. The
    latest version of the Associating Style Sheets with XML documents
    specification is available at <a
    href="http://www.w3.org/TR/xml-stylesheet/">http://www.w3.org/TR/xml-stylesheet/</a>
  </dl>
-->
</html>
<!--XXX WANTED:

some way of initializing internal fields as pointing to the DOM Nodes
of anon content, so that the constructor doesn't have to walk content,
e.g. to set mInputElement in a <textbox> binding containing an <input
type="text">.

maximum number of nodes per <content>, with overflow to other
<content>s


Nickolay Ponomarev:
  A way to say that the element supports onfoo="" handlers.
  A way to easily fire custom events.

-->
