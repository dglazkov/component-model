Attribute/property forwarding:
* must account for weird property/value disparity (see input.value here: http://dev.w3.org/html5/spec/Overview.html#concept-input-value-dirty-flag)
    -- this is what watchAttribute does.

* a V8 interceptor-like listener?
    --- yes, see watchAttribute.

Multiple decorators multicast attribute changes.


Stability of decorators -- ensure consistent order in which they are applied and removed.
Deterministic binding -- ensure that applying decorators is deterministic and knowable.

Decorator document -- the notion that multiple untrusted decorators could exist in the same
document, which has a DOMWindow-like global object, but no access to the actual document.

Decorator global object -- a decorator could be instantiated into a scripting scope that
is different from that of the document:

* looks and feels as if part of the iframe, except document.body == null and document.head == null,
instead document.decorators contains the array of the currently bound decorators. WTF?! 

Airlock:

* If the document trusts the decorator, the decorator can see .element
property and thus traverse outside of the shadow DOM. If it does not,
the .element property is null and the only way the decorator can sense
the world outside is by listening to events on DecoratorContext and
watching properties.

* Conversely, if the decorator trusts the document, the decorator sets
.revealDecorator property and the document receives the object as a
return value of the element.decorate(...) method. Otherwise, the
document's only way to communicate with the decorator is by listening
to events fired from the decorated element and changing
properties/attributes on the element.

What if the component wants to include jquery? How do we make this more efficient?

function Grabbers(context) {
    context.addEventListener('createSubtree', function(evt)
    {
        this.shadowRoot
    }, false);
    context.addEventListener('removeSubtree', function(evt)
    {
        
    }, false);
}

var Grabbers = {
    applyAuthorSheets: true,
    ...
    onApply: function(context)
    {
        // create subtree.
    }
};

// Also:
mixin Grabbers {
    
}


// explicit binding.
var foo = document.getElementById("foo");
var id = foo.addShadow(Grabbers);
foo.removeShadow(id, Grabbers);


interface ShadowContext {
    bool applyAuthorSheets;
    ...
    shadowRoot
}

-----
Instantiation: object's constructor is called.
----
Subtree Creation: context fires "createSubtree" event
---
Existence
--
Subtree Removal: context fires "removeSubtree" event
---
Finalization: nothing.